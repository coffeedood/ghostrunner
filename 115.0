from reportlab.lib.pagesizes import letter
from reportlab.pdfgen import canvas
import tkinter as tk
from tkinter import messagebox
import json
import os
PROFILES_FILE = "profiles.json"

# Function to load profiles from JSON file
def load_profiles():
    if os.path.exists(PROFILES_FILE):
        with open(PROFILES_FILE, "r") as file:
            return json.load(file)
    return []

# Function to save profiles to JSON file
def save_profiles(profiles):
    with open(PROFILES_FILE, "w") as file:
        json.dump(profiles, file, indent=4)

# Load profiles initially
profiles = load_profiles()

# Function to save selected next steps to the profiles.json file


# Function to open the Vehicles window
def open_vehicles_window(profile_name, update_status_callback):
    vehicles_window = tk.Toplevel()
    vehicles_window.title(f"Manage vehicles for {profile_name}")

    tk.Label(vehicles_window, text="Vehicle Brand:").pack(pady=5)
    name_entry = tk.Entry(vehicles_window)
    name_entry.pack(pady=5)
    name_entry.focus_set()  # Set focus to the vehicle name entry field

    tk.Label(vehicles_window, text="Vehicle Model:").pack(pady=5)
    model_entry = tk.Entry(vehicles_window)
    model_entry.pack(pady=5)

    tk.Label(vehicles_window, text="Vehicle Color:").pack(pady=5)
    color_entry = tk.Entry(vehicles_window)
    color_entry.pack(pady=5)

    tk.Label(vehicles_window, text="Vehicle Address:").pack(pady=5)
    address_entry = tk.Entry(vehicles_window)
    address_entry.pack(pady=5)

    tk.Label(vehicles_window, text="Ownership Status:").pack(pady=5)
    relation_var = tk.StringVar(value="Friend")  # Default relation

    # Relation radio buttons
    relation_frame = tk.Frame(vehicles_window)
    relation_frame.pack(pady=5)
    tk.Radiobutton(relation_frame, text="Owner", variable=relation_var, value="Owner").pack(side=tk.LEFT, padx=5)
    tk.Radiobutton(relation_frame, text="This is a Rental Car", variable=relation_var, value="This is a Rental Car").pack(side=tk.LEFT, padx=5)
    tk.Radiobutton(relation_frame, text="Other", variable=relation_var, value="Other").pack(side=tk.LEFT, padx=5)

    # vehicles list display
    vehicles_listbox = tk.Listbox(vehicles_window, height=10, width=50)
    vehicles_listbox.pack(pady=10)

    def refresh_vehicles():
        vehicles_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for vehicle in profile_data.get('vehicles', []):
                vehicle_details = f"{vehicle['name']} | {vehicle['model']} | {vehicle['color']} | {vehicle['address']}| {vehicle['relation']}"
                vehicles_listbox.insert(tk.END, vehicle_details)

    def save_vehicle():
        vehicle_name = name_entry.get()
        model_number = model_entry.get()
        color_address = color_entry.get()
        address = address_entry.get()
        relation = relation_var.get()

        if vehicle_name and model_number and color_address and address and relation:
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'vehicles' not in profile_data:
                    profile_data['vehicles'] = []
                profile_data['vehicles'].append({
                    "name": vehicle_name,
                    "model": model_number,
                    "color": color_address,
                    "address": address,
                    "relation": relation
                })
                # Clear the entry fields after saving
                name_entry.delete(0, tk.END)
                model_entry.delete(0, tk.END)
                color_entry.delete(0, tk.END)
                address_entry.delete(0, tk.END)
                
                update_status_callback()  # Update the vehicle status label
                refresh_vehicles()  # Refresh the vehicle list display
                save_profiles(profiles)  # Save profiles to file
        else:
            messagebox.showwarning("Input Error", "Please fill all fields.")

    tk.Button(vehicles_window, text="Save vehicle", command=save_vehicle).pack(pady=5)
    refresh_vehicles()  # Initial population of the vehicle list


import tkinter as tk
from tkinter import messagebox
from reportlab.lib.pagesizes import letter
from reportlab.pdfgen import canvas
from tkinter import *

from reportlab.lib.pagesizes import letter
from reportlab.pdfgen import canvas as pdf_canvas
from tkinter import filedialog, messagebox
from reportlab.lib.pagesizes import letter
from reportlab.pdfgen import canvas as pdf_canvas
from reportlab.lib.units import inch


def open_contacts_window(profile_name, update_status_callback):
    contacts_window = tk.Toplevel()
    contacts_window.title(f"Manage Contacts for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(contacts_window)
    scrollbar = tk.Scrollbar(contacts_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Existing fields for adding a contact
    tk.Label(scrollable_frame, text="Contact Name:").pack(pady=5)
    name_entry = tk.Entry(scrollable_frame)
    name_entry.pack(pady=5)
    name_entry.focus_set()

    tk.Label(scrollable_frame, text="Phone Number:").pack(pady=5)
    phone_entry = tk.Entry(scrollable_frame)
    phone_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Email Address:").pack(pady=5)
    email_entry = tk.Entry(scrollable_frame)
    email_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Address:").pack(pady=5)
    address_entry = tk.Entry(scrollable_frame)
    address_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Relation:").pack(pady=5)
    relation_var = tk.StringVar(value="Friend")

    # Relation radio buttons
    relation_frame = tk.Frame(scrollable_frame)
    relation_frame.pack(pady=5)
    tk.Radiobutton(relation_frame, text="Friend", variable=relation_var, value="Friend").pack(side=tk.LEFT, padx=5)
    tk.Radiobutton(relation_frame, text="Acquaintance", variable=relation_var, value="Acquaintance").pack(side=tk.LEFT, padx=5)
    tk.Radiobutton(relation_frame, text="Other", variable=relation_var, value="Other").pack(side=tk.LEFT, padx=5)

    # New fields for additional profile data
    additional_fields = [
        ("First Name", ""),
        ("Middle Name", ""),
        ("Last Name", ""),
        ("Maiden Name", ""),
        ("Date of Birth", ""),
        ("Birthplace", ""),
        ("Location of Birth Certificate", ""),
        ("Location of Adoption Documents", ""),
        ("Social Security Number", ""),
        ("Location of Social Security Card", ""),
        ("Driver’s License Number and State", "")
    ]
    
    entries = {}
    for field_name, _ in additional_fields:
        tk.Label(scrollable_frame, text=f"{field_name}:").pack(pady=5)
        entry = tk.Entry(scrollable_frame)
        entry.pack(pady=5)
        entries[field_name.lower().replace(" ", "_")] = entry

    # Contacts list display
    contacts_listbox = tk.Listbox(scrollable_frame, height=10, width=50)
    contacts_listbox.pack(pady=10)

    def refresh_contacts():
        contacts_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for contact in profile_data.get('contacts', []):
                contact_details = f"{contact['name']} | {contact['phone']} | {contact['email']} | {contact['address']} | {contact['relation']} | {contact['first_name']}"
                contacts_listbox.insert(tk.END, contact_details)

    def save_contact():
        # Gather data from entries
        contact_data = {
            "name": name_entry.get(),
            "phone": phone_entry.get(),
            "email": email_entry.get(),
            "address": address_entry.get(),
            "relation": relation_var.get()
        }
        for key, entry in entries.items():
            contact_data[key] = entry.get()

        # Check if all fields are filled
        if all(contact_data.values()):
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'contacts' not in profile_data:
                    profile_data['contacts'] = []
                profile_data['contacts'].append(contact_data)
                # Clear the entry fields after saving
                name_entry.delete(0, tk.END)
                phone_entry.delete(0, tk.END)
                email_entry.delete(0, tk.END)
                address_entry.delete(0, tk.END)
                for entry in entries.values():
                    entry.delete(0, tk.END)
                update_status_callback()
                refresh_contacts()
                save_profiles(profiles)
        else:
            messagebox.showwarning("Input Error", "Please fill all fields.")

    def open_contact_details(contact):
        contact_window = tk.Toplevel(contacts_window)
        contact_window.title(f"Details for {contact['name']}")

        details_entries = {}
        row = 0
        for key, value in contact.items():
            label = tk.Label(contact_window, text=key.replace('_', ' ').title())
            label.grid(row=row, column=0, padx=5, pady=5, sticky=tk.W)
            entry = tk.Entry(contact_window, width=40)
            entry.grid(row=row, column=1, padx=5, pady=5)
            entry.insert(0, value)
            details_entries[key] = entry
            row += 1

        def save_changes():
            for key, entry in details_entries.items():
                contact[key] = entry.get()
            messagebox.showinfo("Saved", "Changes have been saved.")
            contact_window.destroy()
            refresh_contacts()
            save_profiles(profiles)

        tk.Button(contact_window, text="Save Changes", command=save_changes).grid(row=row, columnspan=2, pady=10)

    def on_contact_double_click(event):
        selection = contacts_listbox.curselection()
        if selection:
            selected_index = selection[0]
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                contact = profile_data.get('contacts', [])[selected_index]
                open_contact_details(contact)


    def generate_pdf_of_contacts():
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if not profile_data or 'contacts' not in profile_data or not profile_data['contacts']:
            messagebox.showinfo("No Contacts", "No contacts to generate PDF.")
            return

        # Open a file dialog to select where to save the PDF
        file_name = filedialog.asksaveasfilename(
            defaultextension=".pdf",
            filetypes=[("PDF files", "*.pdf")],
            title="Save PDF as"
        )

        # If the user cancels the save dialog, return without doing anything
        if not file_name:
            return

        # Define margins and line height
        left_margin = inch
        right_margin = 7.5 * inch  # page width is 8.5 inches, so 7.5 gives a 1-inch margin on the right
        top_margin = 10 * inch - 0.5 * inch
        line_height = 14

        pdf = pdf_canvas.Canvas(file_name, pagesize=letter)
        pdf.setFont("Helvetica", 12)
        y_position = top_margin

        # Title of the PDF
        pdf.drawString(left_margin, y_position, f"Contacts for {profile_name}")
        y_position -= line_height * 2

        # Write each contact's details with word wrapping
        for contact in profile_data['contacts']:
            contact_details = (
                f"Name: {contact.get('name', '')}\n"
                f"Phone: {contact.get('phone', '')}\n"
                f"Email: {contact.get('email', '')}\n"
                f"Address: {contact.get('address', '')}\n"
                f"Relation: {contact.get('relation', '')}\n"
                f"First Name: {contact.get('first_name', '')}\n"
                f"Last Name: {contact.get('last_name', '')}\n"
            )

            # Wrap the text if it exceeds the right margin
            for line in contact_details.split("\n"):
                wrapped_text = pdf.beginText(left_margin, y_position)
                wrapped_text.setFont("Helvetica", 12)
                wrapped_text.setWordSpace(2)

                # Break lines that are too long to fit within the margins
                max_width = right_margin - left_margin
                while line:
                    text_width = pdf.stringWidth(line, "Helvetica", 12)
                    if text_width <= max_width:
                        wrapped_text.textLine(line)
                        line = ""
                    else:
                        # Find the maximum length that fits and split the line
                        for i in range(len(line), 0, -1):
                            if pdf.stringWidth(line[:i], "Helvetica", 12) <= max_width:
                                wrapped_text.textLine(line[:i])
                                line = line[i:].lstrip()
                                break
                pdf.drawText(wrapped_text)
                y_position -= line_height

                # If we reach the bottom of the page, create a new page
                if y_position < inch:
                    pdf.showPage()
                    pdf.setFont("Helvetica", 12)
                    y_position = top_margin

            # Add extra space between contacts
            y_position -= line_height

            # If we reach the bottom of the page, create a new page
            if y_position < inch:
                pdf.showPage()
                pdf.setFont("Helvetica", 12)
                y_position = top_margin

        pdf.save()
        messagebox.showinfo("PDF Generated", f"PDF saved as {file_name}")




    # Bind double-click event to listbox
    contacts_listbox.bind("<Double-1>", on_contact_double_click)

    # Save and PDF buttons
    tk.Button(scrollable_frame, text="Save Contact", command=save_contact).pack(pady=5)
    tk.Button(scrollable_frame, text="Generate PDF", command=generate_pdf_of_contacts).pack(pady=5)

    refresh_contacts()



def open_credit_window(profile_name, update_status_callback):
    credit_window = tk.Toplevel()
    credit_window.title(f"Manage credit for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(credit_window)
    scrollbar = tk.Scrollbar(credit_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Existing fields for adding a contact
    tk.Label(scrollable_frame, text="Contact Name:").pack(pady=5)
    name_entry = tk.Entry(scrollable_frame)
    name_entry.pack(pady=5)
    name_entry.focus_set()

    tk.Label(scrollable_frame, text="Phone Number:").pack(pady=5)
    phone_entry = tk.Entry(scrollable_frame)
    phone_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Email Address:").pack(pady=5)
    email_entry = tk.Entry(scrollable_frame)
    email_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Address:").pack(pady=5)
    address_entry = tk.Entry(scrollable_frame)
    address_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Relation:").pack(pady=5)
    relation_var = tk.StringVar(value="Friend")

    # Relation radio buttons
    relation_frame = tk.Frame(scrollable_frame)
    relation_frame.pack(pady=5)
    tk.Radiobutton(relation_frame, text="Friend", variable=relation_var, value="Friend").pack(side=tk.LEFT, padx=5)
    tk.Radiobutton(relation_frame, text="Acquaintance", variable=relation_var, value="Acquaintance").pack(side=tk.LEFT, padx=5)
    tk.Radiobutton(relation_frame, text="Other", variable=relation_var, value="Other").pack(side=tk.LEFT, padx=5)

    # New fields for additional profile data
    additional_fields = [
        ("First Name", ""),
        ("Middle Name", ""),
        ("Last Name", ""),
        ("Maiden Name", ""),
        ("Date of Birth", ""),
        ("Birthplace", ""),
        ("Location of Birth Certificate", ""),
        ("Location of Adoption Documents", ""),
        ("Social Security Number", ""),
        ("Location of Social Security Card", ""),
        ("Driver’s License Number and State", "")
    ]
    
    entries = {}
    for field_name, _ in additional_fields:
        tk.Label(scrollable_frame, text=f"{field_name}:").pack(pady=5)
        entry = tk.Entry(scrollable_frame)
        entry.pack(pady=5)
        entries[field_name.lower().replace(" ", "_")] = entry

    # credit list display
    credit_listbox = tk.Listbox(scrollable_frame, height=10, width=50)
    credit_listbox.pack(pady=10)

    def refresh_credit():
        credit_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for contact in profile_data.get('credit', []):
                contact_details = f"{contact['name']} | {contact['phone']} | {contact['email']} | {contact['address']} | {contact['relation']} | {contact['first_name']}"
                credit_listbox.insert(tk.END, contact_details)

    def save_contact():
        # Gather data from entries
        contact_data = {
            "name": name_entry.get(),
            "phone": phone_entry.get(),
            "email": email_entry.get(),
            "address": address_entry.get(),
            "relation": relation_var.get()
        }
        for key, entry in entries.items():
            contact_data[key] = entry.get()

        # Check if all fields are filled
        if all(contact_data.values()):
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'credit' not in profile_data:
                    profile_data['credit'] = []
                profile_data['credit'].append(contact_data)
                # Clear the entry fields after saving
                name_entry.delete(0, tk.END)
                phone_entry.delete(0, tk.END)
                email_entry.delete(0, tk.END)
                address_entry.delete(0, tk.END)
                for entry in entries.values():
                    entry.delete(0, tk.END)
                update_status_callback()
                refresh_credit()
                save_profiles(profiles)
        else:
            messagebox.showwarning("Input Error", "Please fill all fields.")

    def open_contact_details(contact):
        contact_window = tk.Toplevel(credit_window)
        contact_window.title(f"Details for {contact['name']}")

        details_entries = {}
        row = 0
        for key, value in contact.items():
            label = tk.Label(contact_window, text=key.replace('_', ' ').title())
            label.grid(row=row, column=0, padx=5, pady=5, sticky=tk.W)
            entry = tk.Entry(contact_window, width=40)
            entry.grid(row=row, column=1, padx=5, pady=5)
            entry.insert(0, value)
            details_entries[key] = entry
            row += 1

        def save_changes():
            for key, entry in details_entries.items():
                contact[key] = entry.get()
            messagebox.showinfo("Saved", "Changes have been saved.")
            contact_window.destroy()
            refresh_credit()
            save_profiles(profiles)

        tk.Button(contact_window, text="Save Changes", command=save_changes).grid(row=row, columnspan=2, pady=10)

    def on_contact_double_click(event):
        selection = credit_listbox.curselection()
        if selection:
            selected_index = selection[0]
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                contact = profile_data.get('credit', [])[selected_index]
                open_contact_details(contact)


    def generate_pdf_of_credit():
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if not profile_data or 'credit' not in profile_data or not profile_data['credit']:
            messagebox.showinfo("No credit", "No credit to generate PDF.")
            return

        # Open a file dialog to select where to save the PDF
        file_name = filedialog.asksaveasfilename(
            defaultextension=".pdf",
            filetypes=[("PDF files", "*.pdf")],
            title="Save PDF as"
        )

        # If the user cancels the save dialog, return without doing anything
        if not file_name:
            return

        # Define margins and line height
        left_margin = inch
        right_margin = 7.5 * inch  # page width is 8.5 inches, so 7.5 gives a 1-inch margin on the right
        top_margin = 10 * inch - 0.5 * inch
        line_height = 14

        pdf = pdf_canvas.Canvas(file_name, pagesize=letter)
        pdf.setFont("Helvetica", 12)
        y_position = top_margin

        # Title of the PDF
        pdf.drawString(left_margin, y_position, f"credit for {profile_name}")
        y_position -= line_height * 2

        # Write each contact's details with word wrapping
        for contact in profile_data['credit']:
            contact_details = (
                f"Name: {contact.get('name', '')}\n"
                f"Phone: {contact.get('phone', '')}\n"
                f"Email: {contact.get('email', '')}\n"
                f"Address: {contact.get('address', '')}\n"
                f"Relation: {contact.get('relation', '')}\n"
                f"First Name: {contact.get('first_name', '')}\n"
                f"Last Name: {contact.get('last_name', '')}\n"
            )

            # Wrap the text if it exceeds the right margin
            for line in contact_details.split("\n"):
                wrapped_text = pdf.beginText(left_margin, y_position)
                wrapped_text.setFont("Helvetica", 12)
                wrapped_text.setWordSpace(2)

                # Break lines that are too long to fit within the margins
                max_width = right_margin - left_margin
                while line:
                    text_width = pdf.stringWidth(line, "Helvetica", 12)
                    if text_width <= max_width:
                        wrapped_text.textLine(line)
                        line = ""
                    else:
                        # Find the maximum length that fits and split the line
                        for i in range(len(line), 0, -1):
                            if pdf.stringWidth(line[:i], "Helvetica", 12) <= max_width:
                                wrapped_text.textLine(line[:i])
                                line = line[i:].lstrip()
                                break
                pdf.drawText(wrapped_text)
                y_position -= line_height

                # If we reach the bottom of the page, create a new page
                if y_position < inch:
                    pdf.showPage()
                    pdf.setFont("Helvetica", 12)
                    y_position = top_margin

            # Add extra space between credit
            y_position -= line_height

            # If we reach the bottom of the page, create a new page
            if y_position < inch:
                pdf.showPage()
                pdf.setFont("Helvetica", 12)
                y_position = top_margin

        pdf.save()
        messagebox.showinfo("PDF Generated", f"PDF saved as {file_name}")




    # Bind double-click event to listbox
    credit_listbox.bind("<Double-1>", on_contact_double_click)

    # Save and PDF buttons
    tk.Button(scrollable_frame, text="Save Contact", command=save_contact).pack(pady=5)
    tk.Button(scrollable_frame, text="Generate PDF", command=generate_pdf_of_credit).pack(pady=5)

    refresh_credit()

def open_employment_window(profile_name, update_status_callback):
    employment_window = tk.Toplevel()
    employment_window.title(f"Manage Employment for {profile_name}")

    tk.Label(employment_window, text="Employer Name:").pack(pady=5)
    employer_entry = tk.Entry(employment_window)
    employer_entry.pack(pady=5)
    employer_entry.focus_set()

    tk.Label(employment_window, text="Position:").pack(pady=5)
    position_entry = tk.Entry(employment_window)
    position_entry.pack(pady=5)

    tk.Label(employment_window, text="Start Date (YYYY-MM-DD):").pack(pady=5)
    start_date_entry = tk.Entry(employment_window)
    start_date_entry.pack(pady=5)

    tk.Label(employment_window, text="End Date (YYYY-MM-DD):").pack(pady=5)
    end_date_entry = tk.Entry(employment_window)
    end_date_entry.pack(pady=5)

    tk.Label(employment_window, text="Address:").pack(pady=5)
    address_entry = tk.Entry(employment_window)
    address_entry.pack(pady=5)

    employment_listbox = tk.Listbox(employment_window, height=10, width=70)
    employment_listbox.pack(pady=10)

    def refresh_employment():
        employment_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for job in profile_data.get('employment', []):
                job_details = f"{job['employer']} | {job['position']} | {job['start_date']} - {job['end_date']} | {job['address']}"
                employment_listbox.insert(tk.END, job_details)

    def save_employment():
        employer = employer_entry.get()
        position = position_entry.get()
        start_date = start_date_entry.get()
        end_date = end_date_entry.get()
        address = address_entry.get()

        if employer and position and start_date and address:
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'employment' not in profile_data:
                    profile_data['employment'] = []
                profile_data['employment'].append({
                    "employer": employer,
                    "position": position,
                    "start_date": start_date,
                    "end_date": end_date,
                    "address": address
                })
                employer_entry.delete(0, tk.END)
                position_entry.delete(0, tk.END)
                start_date_entry.delete(0, tk.END)
                end_date_entry.delete(0, tk.END)
                address_entry.delete(0, tk.END)

                update_status_callback()  # Update status for the employment section
                refresh_employment()  # Refresh the listbox
                save_profiles(profiles)  # Save profiles to file
        else:
            messagebox.showwarning("Input Error", "Please fill all required fields.")

    tk.Button(employment_window, text="Save Job", command=save_employment).pack(pady=5)
    refresh_employment()


import os
from tkinter import filedialog

# Function to generate a PDF for a given profile
def generate_profile_pdf(profile_name):
    profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
    if not profile_data:
        messagebox.showwarning("Profile Not Found", f"Profile '{profile_name}' does not exist.")
        return

    # Ask the user to select a folder to save the PDF
    folder_path = filedialog.askdirectory(title="Select Folder to Save PDF")
    if not folder_path:
        messagebox.showwarning("No Folder Selected", "Please select a folder to save the PDF.")
        return

    # Construct the full path for the PDF file
    pdf_filename = os.path.join(folder_path, f"{profile_name}_profile.pdf")
    c = canvas.Canvas(pdf_filename, pagesize=letter)
    width, height = letter

    # Set title and profile name at the top
    c.setFont("Helvetica-Bold", 16)
    c.drawString(100, height - 40, f"Profile: {profile_name}")
    c.setFont("Helvetica", 12)

    # Add Next Steps
    next_steps = profile_data.get('next_steps', {})
    c.drawString(100, height - 80, "Next Steps:")
    y_position = height - 100
    for step, response in next_steps.items():
        c.drawString(110, y_position, f"{step}: {response}")
        y_position -= 20

    # Add Contacts
    c.drawString(100, y_position - 20, "Contacts:")
    y_position -= 40
    for contact in profile_data.get('contacts', []):
        contact_info = f"Name: {contact['name']}, Phone: {contact['phone']}, Email: {contact['email']}, Address: {contact['address']}, Relation: {contact['relation']}"
        c.drawString(110, y_position, contact_info)
        y_position -= 20

    # Add Vehicles
    c.drawString(100, y_position - 20, "Vehicles:")
    y_position -= 40
    for vehicle in profile_data.get('vehicles', []):
        make = vehicle.get('name', 'N/A')
        model = vehicle.get('model', 'N/A')
        color = vehicle.get('color', 'N/A')
        year = vehicle.get('year', 'N/A')
        vehicle_info = f"Make: {make}, Model: {model}, Color: {color}, Year: {year}"
        c.drawString(110, y_position, vehicle_info)
        y_position -= 20

    # Save and close the PDF
    c.showPage()
    c.save()

    messagebox.showinfo("PDF Generated", f"PDF for {profile_name} has been generated and saved to '{pdf_filename}'.")

from reportlab.lib.pagesizes import letter
from reportlab.pdfgen import canvas
import tkinter as tk
from tkinter import messagebox
import json
import os
PROFILES_FILE = "profiles.json"

# Function to load profiles from JSON file
def load_profiles():
    if os.path.exists(PROFILES_FILE):
        with open(PROFILES_FILE, "r") as file:
            return json.load(file)
    return []

# Function to save profiles to JSON file
def save_profiles(profiles):
    with open(PROFILES_FILE, "w") as file:
        json.dump(profiles, file, indent=4)

# Load profiles initially
profiles = load_profiles()

def open_next_steps_window(profile_name, update_status_callback):
    steps_window = tk.Toplevel()
    steps_window.title(f"Manage Next Steps for {profile_name}")

    tk.Label(steps_window, text="Next Steps (Yes or No):", font=("Arial", 14)).pack(pady=10)

    # List of next steps
    steps = [
        "Locate Will or Other Estate Planning Documents",
        "Will and Trust",
        "Contact Organizations and Service Providers",
        "Insurance",
        "Bank and Brokerage Accounts",
        "Retirement Plans and Pensions",
        "Government Benefits",
        "Service Providers",
    ]

    # Load profiles and get the selected profile's data
    profile_data = next((profile for profile in profiles if profile["name"] == profile_name), None)
    if not profile_data:
        messagebox.showerror("Error", f"Profile '{profile_name}' not found.")
        return

    selected_steps = profile_data.get("next_steps", {})
    step_vars = {}  # Dictionary to hold StringVars for each step

    # Listbox to display current steps
    steps_listbox = tk.Listbox(steps_window, height=10, width=70)
    steps_listbox.pack(pady=10)

    def refresh_next_steps():
        """Refresh the listbox to show the current status of next steps."""
        steps_listbox.delete(0, tk.END)
        for step in steps:
            status = selected_steps.get(step, "No")
            steps_listbox.insert(tk.END, f"{step}: {status}")

    def save_step():
        """Save the step data to the profile."""
        for step, var in step_vars.items():
            selected_steps[step] = var.get()

        profile_data["next_steps"] = selected_steps  # Update profile's next steps
        save_profiles(profiles)  # Save profiles to file
        refresh_next_steps()  # Refresh the list display
        update_status_callback()  # Immediately update the status label

    # Create widgets for each step
    for step in steps:
        step_frame = tk.Frame(steps_window)
        step_frame.pack(anchor=tk.W, pady=5)

        # Step label
        tk.Label(step_frame, text=step, font=("Arial", 12)).pack(side=tk.LEFT)

        # StringVar to hold "Yes" or "No" for each step
        step_vars[step] = tk.StringVar(value=selected_steps.get(step, "No"))

        # Yes/No radio buttons
        yes_rb = tk.Radiobutton(step_frame, text="Yes", variable=step_vars[step], value="Yes")
        no_rb = tk.Radiobutton(step_frame, text="No", variable=step_vars[step], value="No")

        yes_rb.pack(side=tk.LEFT, padx=5)
        no_rb.pack(side=tk.LEFT, padx=5)

    # Save Button
    tk.Button(steps_window, text="Save Changes", command=save_step).pack(pady=10)

    refresh_next_steps()  # Initial population of the steps list



# Function to open the Vehicles window
def open_vehicles_window(profile_name, update_status_callback):
    vehicles_window = tk.Toplevel()
    vehicles_window.title(f"Manage vehicles for {profile_name}")

    tk.Label(vehicles_window, text="Vehicle Brand:").pack(pady=5)
    name_entry = tk.Entry(vehicles_window)
    name_entry.pack(pady=5)
    name_entry.focus_set()  # Set focus to the vehicle name entry field

    tk.Label(vehicles_window, text="Vehicle Model:").pack(pady=5)
    model_entry = tk.Entry(vehicles_window)
    model_entry.pack(pady=5)

    tk.Label(vehicles_window, text="Vehicle Color:").pack(pady=5)
    color_entry = tk.Entry(vehicles_window)
    color_entry.pack(pady=5)

    tk.Label(vehicles_window, text="Vehicle Address:").pack(pady=5)
    address_entry = tk.Entry(vehicles_window)
    address_entry.pack(pady=5)

    tk.Label(vehicles_window, text="Ownership Status:").pack(pady=5)
    relation_var = tk.StringVar(value="Friend")  # Default relation

    # Relation radio buttons
    relation_frame = tk.Frame(vehicles_window)
    relation_frame.pack(pady=5)
    tk.Radiobutton(relation_frame, text="Owner", variable=relation_var, value="Owner").pack(side=tk.LEFT, padx=5)
    tk.Radiobutton(relation_frame, text="This is a Rental Car", variable=relation_var, value="This is a Rental Car").pack(side=tk.LEFT, padx=5)
    tk.Radiobutton(relation_frame, text="Other", variable=relation_var, value="Other").pack(side=tk.LEFT, padx=5)

    # vehicles list display
    vehicles_listbox = tk.Listbox(vehicles_window, height=10, width=50)
    vehicles_listbox.pack(pady=10)

    def refresh_vehicles():
        vehicles_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for vehicle in profile_data.get('vehicles', []):
                vehicle_details = f"{vehicle['name']} | {vehicle['model']} | {vehicle['color']} | {vehicle['address']}| {vehicle['relation']}"
                vehicles_listbox.insert(tk.END, vehicle_details)

    def save_vehicle():
        vehicle_name = name_entry.get()
        model_number = model_entry.get()
        color_address = color_entry.get()
        address = address_entry.get()
        relation = relation_var.get()

        if vehicle_name and model_number and color_address and address and relation:
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'vehicles' not in profile_data:
                    profile_data['vehicles'] = []
                profile_data['vehicles'].append({
                    "name": vehicle_name,
                    "model": model_number,
                    "color": color_address,
                    "address": address,
                    "relation": relation
                })
                # Clear the entry fields after saving
                name_entry.delete(0, tk.END)
                model_entry.delete(0, tk.END)
                color_entry.delete(0, tk.END)
                address_entry.delete(0, tk.END)
                
                update_status_callback()  # Update the vehicle status label
                refresh_vehicles()  # Refresh the vehicle list display
                save_profiles(profiles)  # Save profiles to file
        else:
            messagebox.showwarning("Input Error", "Please fill all fields.")

    tk.Button(vehicles_window, text="Save vehicle", command=save_vehicle).pack(pady=5)
    refresh_vehicles()  # Initial population of the vehicle list


import tkinter as tk
from tkinter import messagebox
from reportlab.lib.pagesizes import letter
from reportlab.pdfgen import canvas
from tkinter import *

from reportlab.lib.pagesizes import letter
from reportlab.pdfgen import canvas as pdf_canvas
from tkinter import filedialog, messagebox
from reportlab.lib.pagesizes import letter
from reportlab.pdfgen import canvas as pdf_canvas
from reportlab.lib.units import inch


def open_contacts_window(profile_name, update_status_callback):
    contacts_window = tk.Toplevel()
    contacts_window.title(f"Manage Contacts for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(contacts_window)
    scrollbar = tk.Scrollbar(contacts_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Existing fields for adding a contact
    tk.Label(scrollable_frame, text="Contact Name:").pack(pady=5)
    name_entry = tk.Entry(scrollable_frame)
    name_entry.pack(pady=5)
    name_entry.focus_set()

    tk.Label(scrollable_frame, text="Phone Number:").pack(pady=5)
    phone_entry = tk.Entry(scrollable_frame)
    phone_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Email Address:").pack(pady=5)
    email_entry = tk.Entry(scrollable_frame)
    email_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Address:").pack(pady=5)
    address_entry = tk.Entry(scrollable_frame)
    address_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Relation:").pack(pady=5)
    relation_var = tk.StringVar(value="Friend")

    # Relation radio buttons
    relation_frame = tk.Frame(scrollable_frame)
    relation_frame.pack(pady=5)
    tk.Radiobutton(relation_frame, text="Friend", variable=relation_var, value="Friend").pack(side=tk.LEFT, padx=5)
    tk.Radiobutton(relation_frame, text="Acquaintance", variable=relation_var, value="Acquaintance").pack(side=tk.LEFT, padx=5)
    tk.Radiobutton(relation_frame, text="Other", variable=relation_var, value="Other").pack(side=tk.LEFT, padx=5)

    # New fields for additional profile data
    additional_fields = [
        ("First Name", ""),
        ("Middle Name", ""),
        ("Last Name", ""),
        ("Maiden Name", ""),
        ("Date of Birth", ""),
        ("Birthplace", ""),
        ("Location of Birth Certificate", ""),
        ("Location of Adoption Documents", ""),
        ("Social Security Number", ""),
        ("Location of Social Security Card", ""),
        ("Driver’s License Number and State", "")
    ]
    
    entries = {}
    for field_name, _ in additional_fields:
        tk.Label(scrollable_frame, text=f"{field_name}:").pack(pady=5)
        entry = tk.Entry(scrollable_frame)
        entry.pack(pady=5)
        entries[field_name.lower().replace(" ", "_")] = entry

    # Contacts list display
    contacts_listbox = tk.Listbox(scrollable_frame, height=10, width=50)
    contacts_listbox.pack(pady=10)

    def refresh_contacts():
        contacts_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for contact in profile_data.get('contacts', []):
                contact_details = f"{contact['name']} | {contact['phone']} | {contact['email']} | {contact['address']} | {contact['relation']} | {contact['first_name']}"
                contacts_listbox.insert(tk.END, contact_details)

    def save_contact():
        # Gather data from entries
        contact_data = {
            "name": name_entry.get(),
            "phone": phone_entry.get(),
            "email": email_entry.get(),
            "address": address_entry.get(),
            "relation": relation_var.get()
        }
        for key, entry in entries.items():
            contact_data[key] = entry.get()

        # Check if all fields are filled
        if all(contact_data.values()):
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'contacts' not in profile_data:
                    profile_data['contacts'] = []
                profile_data['contacts'].append(contact_data)
                # Clear the entry fields after saving
                name_entry.delete(0, tk.END)
                phone_entry.delete(0, tk.END)
                email_entry.delete(0, tk.END)
                address_entry.delete(0, tk.END)
                for entry in entries.values():
                    entry.delete(0, tk.END)
                update_status_callback()
                refresh_contacts()
                save_profiles(profiles)
        else:
            messagebox.showwarning("Input Error", "Please fill all fields.")

    def open_contact_details(contact):
        contact_window = tk.Toplevel(contacts_window)
        contact_window.title(f"Details for {contact['name']}")

        details_entries = {}
        row = 0
        for key, value in contact.items():
            label = tk.Label(contact_window, text=key.replace('_', ' ').title())
            label.grid(row=row, column=0, padx=5, pady=5, sticky=tk.W)
            entry = tk.Entry(contact_window, width=40)
            entry.grid(row=row, column=1, padx=5, pady=5)
            entry.insert(0, value)
            details_entries[key] = entry
            row += 1

        def save_changes():
            for key, entry in details_entries.items():
                contact[key] = entry.get()
            messagebox.showinfo("Saved", "Changes have been saved.")
            contact_window.destroy()
            refresh_contacts()
            save_profiles(profiles)

        tk.Button(contact_window, text="Save Changes", command=save_changes).grid(row=row, columnspan=2, pady=10)

    def on_contact_double_click(event):
        selection = contacts_listbox.curselection()
        if selection:
            selected_index = selection[0]
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                contact = profile_data.get('contacts', [])[selected_index]
                open_contact_details(contact)


    def generate_pdf_of_contacts():
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if not profile_data or 'contacts' not in profile_data or not profile_data['contacts']:
            messagebox.showinfo("No Contacts", "No contacts to generate PDF.")
            return

        # Open a file dialog to select where to save the PDF
        file_name = filedialog.asksaveasfilename(
            defaultextension=".pdf",
            filetypes=[("PDF files", "*.pdf")],
            title="Save PDF as"
        )

        # If the user cancels the save dialog, return without doing anything
        if not file_name:
            return

        # Define margins and line height
        left_margin = inch
        right_margin = 7.5 * inch  # page width is 8.5 inches, so 7.5 gives a 1-inch margin on the right
        top_margin = 10 * inch - 0.5 * inch
        line_height = 14

        pdf = pdf_canvas.Canvas(file_name, pagesize=letter)
        pdf.setFont("Helvetica", 12)
        y_position = top_margin

        # Title of the PDF
        pdf.drawString(left_margin, y_position, f"Contacts for {profile_name}")
        y_position -= line_height * 2

        # Write each contact's details with word wrapping
        for contact in profile_data['contacts']:
            contact_details = (
                f"Name: {contact.get('name', '')}\n"
                f"Phone: {contact.get('phone', '')}\n"
                f"Email: {contact.get('email', '')}\n"
                f"Address: {contact.get('address', '')}\n"
                f"Relation: {contact.get('relation', '')}\n"
                f"First Name: {contact.get('first_name', '')}\n"
                f"Last Name: {contact.get('last_name', '')}\n"
            )

            # Wrap the text if it exceeds the right margin
            for line in contact_details.split("\n"):
                wrapped_text = pdf.beginText(left_margin, y_position)
                wrapped_text.setFont("Helvetica", 12)
                wrapped_text.setWordSpace(2)

                # Break lines that are too long to fit within the margins
                max_width = right_margin - left_margin
                while line:
                    text_width = pdf.stringWidth(line, "Helvetica", 12)
                    if text_width <= max_width:
                        wrapped_text.textLine(line)
                        line = ""
                    else:
                        # Find the maximum length that fits and split the line
                        for i in range(len(line), 0, -1):
                            if pdf.stringWidth(line[:i], "Helvetica", 12) <= max_width:
                                wrapped_text.textLine(line[:i])
                                line = line[i:].lstrip()
                                break
                pdf.drawText(wrapped_text)
                y_position -= line_height

                # If we reach the bottom of the page, create a new page
                if y_position < inch:
                    pdf.showPage()
                    pdf.setFont("Helvetica", 12)
                    y_position = top_margin

            # Add extra space between contacts
            y_position -= line_height

            # If we reach the bottom of the page, create a new page
            if y_position < inch:
                pdf.showPage()
                pdf.setFont("Helvetica", 12)
                y_position = top_margin

        pdf.save()
        messagebox.showinfo("PDF Generated", f"PDF saved as {file_name}")




    # Bind double-click event to listbox
    contacts_listbox.bind("<Double-1>", on_contact_double_click)

    # Save and PDF buttons
    tk.Button(scrollable_frame, text="Save Contact", command=save_contact).pack(pady=5)
    tk.Button(scrollable_frame, text="Generate PDF", command=generate_pdf_of_contacts).pack(pady=5)

    refresh_contacts()



def open_credit_window(profile_name, update_status_callback):
    credit_window = tk.Toplevel()
    credit_window.title(f"Manage credit for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(credit_window)
    scrollbar = tk.Scrollbar(credit_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Existing fields for adding a contact
    tk.Label(scrollable_frame, text="Contact Name:").pack(pady=5)
    name_entry = tk.Entry(scrollable_frame)
    name_entry.pack(pady=5)
    name_entry.focus_set()

    tk.Label(scrollable_frame, text="Phone Number:").pack(pady=5)
    phone_entry = tk.Entry(scrollable_frame)
    phone_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Email Address:").pack(pady=5)
    email_entry = tk.Entry(scrollable_frame)
    email_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Address:").pack(pady=5)
    address_entry = tk.Entry(scrollable_frame)
    address_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Relation:").pack(pady=5)
    relation_var = tk.StringVar(value="Friend")

    # Relation radio buttons
    relation_frame = tk.Frame(scrollable_frame)
    relation_frame.pack(pady=5)
    tk.Radiobutton(relation_frame, text="Friend", variable=relation_var, value="Friend").pack(side=tk.LEFT, padx=5)
    tk.Radiobutton(relation_frame, text="Acquaintance", variable=relation_var, value="Acquaintance").pack(side=tk.LEFT, padx=5)
    tk.Radiobutton(relation_frame, text="Other", variable=relation_var, value="Other").pack(side=tk.LEFT, padx=5)

    # New fields for additional profile data
    additional_fields = [
        ("First Name", ""),
        ("Middle Name", ""),
        ("Last Name", ""),
        ("Maiden Name", ""),
        ("Date of Birth", ""),
        ("Birthplace", ""),
        ("Location of Birth Certificate", ""),
        ("Location of Adoption Documents", ""),
        ("Social Security Number", ""),
        ("Location of Social Security Card", ""),
        ("Driver’s License Number and State", "")
    ]
    
    entries = {}
    for field_name, _ in additional_fields:
        tk.Label(scrollable_frame, text=f"{field_name}:").pack(pady=5)
        entry = tk.Entry(scrollable_frame)
        entry.pack(pady=5)
        entries[field_name.lower().replace(" ", "_")] = entry

    # credit list display
    credit_listbox = tk.Listbox(scrollable_frame, height=10, width=50)
    credit_listbox.pack(pady=10)

    def refresh_credit():
        credit_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for contact in profile_data.get('credit', []):
                contact_details = f"{contact['name']} | {contact['phone']} | {contact['email']} | {contact['address']} | {contact['relation']} | {contact['first_name']}"
                credit_listbox.insert(tk.END, contact_details)

    def save_contact():
        # Gather data from entries
        contact_data = {
            "name": name_entry.get(),
            "phone": phone_entry.get(),
            "email": email_entry.get(),
            "address": address_entry.get(),
            "relation": relation_var.get()
        }
        for key, entry in entries.items():
            contact_data[key] = entry.get()

        # Check if all fields are filled
        if all(contact_data.values()):
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'credit' not in profile_data:
                    profile_data['credit'] = []
                profile_data['credit'].append(contact_data)
                # Clear the entry fields after saving
                name_entry.delete(0, tk.END)
                phone_entry.delete(0, tk.END)
                email_entry.delete(0, tk.END)
                address_entry.delete(0, tk.END)
                for entry in entries.values():
                    entry.delete(0, tk.END)
                update_status_callback()
                refresh_credit()
                save_profiles(profiles)
        else:
            messagebox.showwarning("Input Error", "Please fill all fields.")

    def open_contact_details(contact):
        contact_window = tk.Toplevel(credit_window)
        contact_window.title(f"Details for {contact['name']}")

        details_entries = {}
        row = 0
        for key, value in contact.items():
            label = tk.Label(contact_window, text=key.replace('_', ' ').title())
            label.grid(row=row, column=0, padx=5, pady=5, sticky=tk.W)
            entry = tk.Entry(contact_window, width=40)
            entry.grid(row=row, column=1, padx=5, pady=5)
            entry.insert(0, value)
            details_entries[key] = entry
            row += 1

        def save_changes():
            for key, entry in details_entries.items():
                contact[key] = entry.get()
            messagebox.showinfo("Saved", "Changes have been saved.")
            contact_window.destroy()
            refresh_credit()
            save_profiles(profiles)

        tk.Button(contact_window, text="Save Changes", command=save_changes).grid(row=row, columnspan=2, pady=10)

    def on_contact_double_click(event):
        selection = credit_listbox.curselection()
        if selection:
            selected_index = selection[0]
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                contact = profile_data.get('credit', [])[selected_index]
                open_contact_details(contact)


    def generate_pdf_of_credit():
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if not profile_data or 'credit' not in profile_data or not profile_data['credit']:
            messagebox.showinfo("No credit", "No credit to generate PDF.")
            return

        # Open a file dialog to select where to save the PDF
        file_name = filedialog.asksaveasfilename(
            defaultextension=".pdf",
            filetypes=[("PDF files", "*.pdf")],
            title="Save PDF as"
        )

        # If the user cancels the save dialog, return without doing anything
        if not file_name:
            return

        # Define margins and line height
        left_margin = inch
        right_margin = 7.5 * inch  # page width is 8.5 inches, so 7.5 gives a 1-inch margin on the right
        top_margin = 10 * inch - 0.5 * inch
        line_height = 14

        pdf = pdf_canvas.Canvas(file_name, pagesize=letter)
        pdf.setFont("Helvetica", 12)
        y_position = top_margin

        # Title of the PDF
        pdf.drawString(left_margin, y_position, f"credit for {profile_name}")
        y_position -= line_height * 2

        # Write each contact's details with word wrapping
        for contact in profile_data['credit']:
            contact_details = (
                f"Name: {contact.get('name', '')}\n"
                f"Phone: {contact.get('phone', '')}\n"
                f"Email: {contact.get('email', '')}\n"
                f"Address: {contact.get('address', '')}\n"
                f"Relation: {contact.get('relation', '')}\n"
                f"First Name: {contact.get('first_name', '')}\n"
                f"Last Name: {contact.get('last_name', '')}\n"
            )

            # Wrap the text if it exceeds the right margin
            for line in contact_details.split("\n"):
                wrapped_text = pdf.beginText(left_margin, y_position)
                wrapped_text.setFont("Helvetica", 12)
                wrapped_text.setWordSpace(2)

                # Break lines that are too long to fit within the margins
                max_width = right_margin - left_margin
                while line:
                    text_width = pdf.stringWidth(line, "Helvetica", 12)
                    if text_width <= max_width:
                        wrapped_text.textLine(line)
                        line = ""
                    else:
                        # Find the maximum length that fits and split the line
                        for i in range(len(line), 0, -1):
                            if pdf.stringWidth(line[:i], "Helvetica", 12) <= max_width:
                                wrapped_text.textLine(line[:i])
                                line = line[i:].lstrip()
                                break
                pdf.drawText(wrapped_text)
                y_position -= line_height

                # If we reach the bottom of the page, create a new page
                if y_position < inch:
                    pdf.showPage()
                    pdf.setFont("Helvetica", 12)
                    y_position = top_margin

            # Add extra space between credit
            y_position -= line_height

            # If we reach the bottom of the page, create a new page
            if y_position < inch:
                pdf.showPage()
                pdf.setFont("Helvetica", 12)
                y_position = top_margin

        pdf.save()
        messagebox.showinfo("PDF Generated", f"PDF saved as {file_name}")




    # Bind double-click event to listbox
    credit_listbox.bind("<Double-1>", on_contact_double_click)

    # Save and PDF buttons
    tk.Button(scrollable_frame, text="Save Contact", command=save_contact).pack(pady=5)
    tk.Button(scrollable_frame, text="Generate PDF", command=generate_pdf_of_credit).pack(pady=5)

    refresh_credit()

def open_employment_window(profile_name, update_status_callback):
    employment_window = tk.Toplevel()
    employment_window.title(f"Manage Employment for {profile_name}")

    tk.Label(employment_window, text="Employer Name:").pack(pady=5)
    employer_entry = tk.Entry(employment_window)
    employer_entry.pack(pady=5)
    employer_entry.focus_set()

    tk.Label(employment_window, text="Position:").pack(pady=5)
    position_entry = tk.Entry(employment_window)
    position_entry.pack(pady=5)

    tk.Label(employment_window, text="Start Date (YYYY-MM-DD):").pack(pady=5)
    start_date_entry = tk.Entry(employment_window)
    start_date_entry.pack(pady=5)

    tk.Label(employment_window, text="End Date (YYYY-MM-DD):").pack(pady=5)
    end_date_entry = tk.Entry(employment_window)
    end_date_entry.pack(pady=5)

    tk.Label(employment_window, text="Address:").pack(pady=5)
    address_entry = tk.Entry(employment_window)
    address_entry.pack(pady=5)

    employment_listbox = tk.Listbox(employment_window, height=10, width=70)
    employment_listbox.pack(pady=10)

    def refresh_employment():
        employment_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for job in profile_data.get('employment', []):
                job_details = f"{job['employer']} | {job['position']} | {job['start_date']} - {job['end_date']} | {job['address']}"
                employment_listbox.insert(tk.END, job_details)

    def save_employment():
        employer = employer_entry.get()
        position = position_entry.get()
        start_date = start_date_entry.get()
        end_date = end_date_entry.get()
        address = address_entry.get()

        if employer and position and start_date and address:
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'employment' not in profile_data:
                    profile_data['employment'] = []
                profile_data['employment'].append({
                    "employer": employer,
                    "position": position,
                    "start_date": start_date,
                    "end_date": end_date,
                    "address": address
                })
                employer_entry.delete(0, tk.END)
                position_entry.delete(0, tk.END)
                start_date_entry.delete(0, tk.END)
                end_date_entry.delete(0, tk.END)
                address_entry.delete(0, tk.END)

                update_status_callback()  # Update status for the employment section
                refresh_employment()  # Refresh the listbox
                save_profiles(profiles)  # Save profiles to file
        else:
            messagebox.showwarning("Input Error", "Please fill all required fields.")

    tk.Button(employment_window, text="Save Job", command=save_employment).pack(pady=5)
    refresh_employment()


import os
from tkinter import filedialog

# Function to generate a PDF for a given profile
def generate_profile_pdf(profile_name):
    profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
    if not profile_data:
        messagebox.showwarning("Profile Not Found", f"Profile '{profile_name}' does not exist.")
        return

    # Ask the user to select a folder to save the PDF
    folder_path = filedialog.askdirectory(title="Select Folder to Save PDF")
    if not folder_path:
        messagebox.showwarning("No Folder Selected", "Please select a folder to save the PDF.")
        return

    # Construct the full path for the PDF file
    pdf_filename = os.path.join(folder_path, f"{profile_name}_profile.pdf")
    c = canvas.Canvas(pdf_filename, pagesize=letter)
    width, height = letter

    # Set title and profile name at the top
    c.setFont("Helvetica-Bold", 16)
    c.drawString(100, height - 40, f"Profile: {profile_name}")
    c.setFont("Helvetica", 12)

    # Add Next Steps
    next_steps = profile_data.get('next_steps', {})
    c.drawString(100, height - 80, "Next Steps:")
    y_position = height - 100
    for step, response in next_steps.items():
        c.drawString(110, y_position, f"{step}: {response}")
        y_position -= 20

    # Add Contacts
    c.drawString(100, y_position - 20, "Contacts:")
    y_position -= 40
    for contact in profile_data.get('contacts', []):
        contact_info = f"Name: {contact['name']}, Phone: {contact['phone']}, Email: {contact['email']}, Address: {contact['address']}, Relation: {contact['relation']}"
        c.drawString(110, y_position, contact_info)
        y_position -= 20

    # Add Vehicles
    c.drawString(100, y_position - 20, "Vehicles:")
    y_position -= 40
    for vehicle in profile_data.get('vehicles', []):
        make = vehicle.get('name', 'N/A')
        model = vehicle.get('model', 'N/A')
        color = vehicle.get('color', 'N/A')
        year = vehicle.get('year', 'N/A')
        vehicle_info = f"Make: {make}, Model: {model}, Color: {color}, Year: {year}"
        c.drawString(110, y_position, vehicle_info)
        y_position -= 20

    # Save and close the PDF
    c.showPage()
    c.save()

    messagebox.showinfo("PDF Generated", f"PDF for {profile_name} has been generated and saved to '{pdf_filename}'.")

def open_biography_window(profile_name, update_status_callback):
    biography_window = tk.Toplevel()
    biography_window.title(f"Manage Biographies for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(biography_window)
    scrollbar = tk.Scrollbar(biography_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Sections and Fields
    sections = [

        ("Your Biography", [
            ("First Name", tk.Entry),
            ("Middle Name", tk.Entry),
            ("Last Name", tk.Entry),
            ("Maiden Name", tk.Entry),
            ("Address", tk.Entry),
            ("Telephone", tk.Entry),
            ("Resident of city since:", tk.Entry),
            ("Resident of state since:", tk.Entry),
            ("Date of Birth", tk.Entry),
            ("Birthplace (City, State, County, Country)", tk.Entry),
            ("Location of Birth Certificate", tk.Entry),
            ("Location of Adoption Documents", tk.Entry),
            ("Social Security Number", tk.Entry),
            ("Location of Social Security Card", tk.Entry),
            ("Driver’s License Number and State", tk.Entry)
        ]),
        ("Military Service", [
            ("Country and Branch", tk.Entry),
            ("Military Rank", tk.Entry),
            ("Military Induction Date", tk.Entry),
            ("Military Discharge Date", tk.Entry),
            ("Military Citations", tk.Entry),
            ("Location of Military Documents", tk.Entry)
        ]),
        ("Marriage Details", [
            ("Date of First Marriage", tk.Entry),
            ("Spouse’s Name", tk.Entry),
            ("Location of Marriage Certificate", tk.Entry),
            ("Date of Divorce/Annulment/Separation/Death", tk.Entry),
            ("Location of Documents", tk.Entry)
        ]),
        ("Other Details", [
            ("Date of Death", tk.Entry),
            ("Location of Death Certificate", tk.Entry),
            ("Other", tk.Entry)
        ])
    ]

    # Dictionary to store field widgets
    field_widgets = {}

    # Generate form fields
    for section, fields in sections:
        tk.Label(scrollable_frame, text=section, font=("Arial", 14, "bold")).pack(pady=10)
        for field_label, field_type in fields:
            tk.Label(scrollable_frame, text=field_label).pack(pady=5)
            entry = field_type(scrollable_frame)
            entry.pack(pady=5, fill=tk.X)
            field_widgets[field_label] = entry

    # Biography list display
    biography_listbox = tk.Listbox(scrollable_frame, height=10, width=100)
    biography_listbox.pack(pady=10)

    # Refresh listbox content
    def refresh_biography_list():
        biography_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for biography in profile_data.get('biographies', []):
                biography_details = " | ".join(f"{key}: {value}" for key, value in biography.items())
                biography_listbox.insert(tk.END, biography_details)

    # Save biography details
    def save_biography():
        biography_data = {label: widget.get() for label, widget in field_widgets.items()}

        # Check if required fields are filled
        if not biography_data["First Name"] or not biography_data["Date of Birth"]:
            messagebox.showwarning("Input Error", "Please fill in the required fields: Name and Date of Birth.")
            return

        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            if 'biographies' not in profile_data:
                profile_data['biographies'] = []
            profile_data['biographies'].append(biography_data)
            
            # Clear fields after saving
            for widget in field_widgets.values():
                widget.delete(0, tk.END)

            update_status_callback()  # Update the status label for this section
            refresh_biography_list()  # Refresh the list display
            save_profiles(profiles)  # Save profiles to file

    # Add button to save biography
    tk.Button(scrollable_frame, text="Save Biography", command=save_biography).pack(pady=10)

    # Populate the listbox with existing biographies
    refresh_biography_list()


def open_biography_window2(profile_name, update_status_callback):
    biography_window = tk.Toplevel()
    biography_window.title(f"Manage Biographies for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(biography_window)
    scrollbar = tk.Scrollbar(biography_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Sections and Fields
    sections = [

        ("Basic Information", [
            ("First Name", tk.Entry),
            ("Middle Name", tk.Entry),
            ("Last Name", tk.Entry),
            ("Maiden Name", tk.Entry),
            ("Address", tk.Entry),
            ("Telephone", tk.Entry),
            ("Resident of city since:", tk.Entry),
            ("Resident of state since:", tk.Entry),
            ("Date of Birth", tk.Entry),
            ("Birthplace (City, State, County, Country)", tk.Entry),
            ("Location of Birth Certificate", tk.Entry),
            ("Location of Adoption Documents", tk.Entry),
            ("Social Security Number", tk.Entry),
            ("Location of Social Security Card", tk.Entry),
            ("Driver’s License Number and State", tk.Entry)
        ]),
        ("Military Service", [
            ("Country and Branch", tk.Entry),
            ("Military Rank", tk.Entry),
            ("Military Induction Date", tk.Entry),
            ("Military Discharge Date", tk.Entry),
            ("Military Citations", tk.Entry),
            ("Location of Military Documents", tk.Entry)
        ]),
        ("Marriage Details", [
            ("Date of First Marriage", tk.Entry),
            ("Spouse’s Name", tk.Entry),
            ("Location of Marriage Certificate", tk.Entry),
            ("Date of Divorce/Annulment/Separation/Death", tk.Entry),
            ("Location of Documents", tk.Entry)
        ]),
        ("Other Details", [
            ("Date of Death", tk.Entry),
            ("Location of Death Certificate", tk.Entry),
            ("Other", tk.Entry)
        ])
    ]

    # Dictionary to store field widgets
    field_widgets = {}

    # Generate form fields
    for section, fields in sections:
        tk.Label(scrollable_frame, text=section, font=("Arial", 14, "bold")).pack(pady=10)
        for field_label, field_type in fields:
            tk.Label(scrollable_frame, text=field_label).pack(pady=5)
            entry = field_type(scrollable_frame)
            entry.pack(pady=5, fill=tk.X)
            field_widgets[field_label] = entry

    # Biography list display
    biography_listbox = tk.Listbox(scrollable_frame, height=10, width=100)
    biography_listbox.pack(pady=10)

    # Refresh listbox content
    def refresh_biography_list():
        biography_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for biography in profile_data.get('biographies2', []):
                biography_details = " | ".join(f"{key}: {value}" for key, value in biography.items())
                biography_listbox.insert(tk.END, biography_details)

    # Save biography details
    def save_biography():
        biography_data = {label: widget.get() for label, widget in field_widgets.items()}

        # Check if required fields are filled
        if not biography_data["First Name"] or not biography_data["Date of Birth"]:
            messagebox.showwarning("Input Error", "Please fill in the required fields: Name and Date of Birth.")
            return

        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            if 'biographies2' not in profile_data:
                profile_data['biographies2'] = []
            profile_data['biographies2'].append(biography_data)
            
            # Clear fields after saving
            for widget in field_widgets.values():
                widget.delete(0, tk.END)

            update_status_callback()  # Update the status label for this section
            refresh_biography_list()  # Refresh the list display
            save_profiles(profiles)  # Save profiles to file

    # Add button to save biography
    tk.Button(scrollable_frame, text="Save Biography", command=save_biography).pack(pady=10)

    # Populate the listbox with existing biographies2
    refresh_biography_list()

def open_biography_window3(profile_name, update_status_callback):
    biography_window = tk.Toplevel()
    biography_window.title(f"Manage Biographies for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(biography_window)
    scrollbar = tk.Scrollbar(biography_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Sections and Fields
    sections = [

        ("Basic Information", [
            ("First Name", tk.Entry),
            ("Middle Name", tk.Entry),
            ("Last Name", tk.Entry),
            ("Maiden Name", tk.Entry),
            ("Address", tk.Entry),
            ("Telephone", tk.Entry),
            ("Resident of city since:", tk.Entry),
            ("Resident of state since:", tk.Entry),
            ("Date of Birth", tk.Entry),
            ("Birthplace (City, State, County, Country)", tk.Entry),
            ("Location of Birth Certificate", tk.Entry),
            ("Location of Adoption Documents", tk.Entry),
            ("Social Security Number", tk.Entry),
            ("Location of Social Security Card", tk.Entry),
            ("Driver’s License Number and State", tk.Entry)
        ]),
        ("Military Service", [
            ("Country and Branch", tk.Entry),
            ("Military Rank", tk.Entry),
            ("Military Induction Date", tk.Entry),
            ("Military Discharge Date", tk.Entry),
            ("Military Citations", tk.Entry),
            ("Location of Military Documents", tk.Entry)
        ]),
        ("Marriage Details", [
            ("Date of First Marriage", tk.Entry),
            ("Spouse’s Name", tk.Entry),
            ("Location of Marriage Certificate", tk.Entry),
            ("Date of Divorce/Annulment/Separation/Death", tk.Entry),
            ("Location of Documents", tk.Entry)
        ]),
        ("Other Details", [
            ("Date of Death", tk.Entry),
            ("Location of Death Certificate", tk.Entry),
            ("Other", tk.Entry)
        ])
    ]

    # Dictionary to store field widgets
    field_widgets = {}

    # Generate form fields
    for section, fields in sections:
        tk.Label(scrollable_frame, text=section, font=("Arial", 14, "bold")).pack(pady=10)
        for field_label, field_type in fields:
            tk.Label(scrollable_frame, text=field_label).pack(pady=5)
            entry = field_type(scrollable_frame)
            entry.pack(pady=5, fill=tk.X)
            field_widgets[field_label] = entry

    # Biography list display
    biography_listbox = tk.Listbox(scrollable_frame, height=10, width=100)
    biography_listbox.pack(pady=10)

    # Refresh listbox content
    def refresh_biography_list():
        biography_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for biography in profile_data.get('biographies3', []):
                biography_details = " | ".join(f"{key}: {value}" for key, value in biography.items())
                biography_listbox.insert(tk.END, biography_details)

    # Save biography details
    def save_biography():
        biography_data = {label: widget.get() for label, widget in field_widgets.items()}

        # Check if required fields are filled
        if not biography_data["First Name"] or not biography_data["Date of Birth"]:
            messagebox.showwarning("Input Error", "Please fill in the required fields: Name and Date of Birth.")
            return

        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            if 'biographies3' not in profile_data:
                profile_data['biographies3'] = []
            profile_data['biographies3'].append(biography_data)
            
            # Clear fields after saving
            for widget in field_widgets.values():
                widget.delete(0, tk.END)

            update_status_callback()  # Update the status label for this section
            refresh_biography_list()  # Refresh the list display
            save_profiles(profiles)  # Save profiles to file

    # Add button to save biography
    tk.Button(scrollable_frame, text="Save Biography", command=save_biography).pack(pady=10)

    # Populate the listbox with existing biographies3
    refresh_biography_list()

def open_pet_livestock_window(profile_name, update_status_callback):
    pet_livestock_window = tk.Toplevel()
    pet_livestock_window.title(f"Manage Pets and Livestock for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(pet_livestock_window)
    scrollbar = tk.Scrollbar(pet_livestock_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Fields for entering pet/livestock details
    tk.Label(scrollable_frame, text="Pet Name:").pack(pady=5)
    name_entry = tk.Entry(scrollable_frame)
    name_entry.pack(pady=5)
    name_entry.focus_set()

    tk.Label(scrollable_frame, text="Species (e.g., Dog, Cow):").pack(pady=5)
    species_entry = tk.Entry(scrollable_frame)
    species_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Coloring:").pack(pady=5)
    coloring_entry = tk.Entry(scrollable_frame)
    coloring_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Location:").pack(pady=5)
    location_entry = tk.Entry(scrollable_frame)
    location_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Food and Water Needs:").pack(pady=5)
    food_water_entry = tk.Entry(scrollable_frame)
    food_water_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Other Care Instructions:").pack(pady=5)
    care_entry = tk.Entry(scrollable_frame)
    care_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Veterinarian's Contact Information:").pack(pady=5)
    vet_contact_entry = tk.Entry(scrollable_frame)
    vet_contact_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Desired Placement (Future Care Plan):").pack(pady=5)
    placement_entry = tk.Entry(scrollable_frame)
    placement_entry.pack(pady=5)

    # Pet/Livestock list display
    pet_livestock_listbox = tk.Listbox(scrollable_frame, height=10, width=100)
    pet_livestock_listbox.pack(pady=10)

    # Refresh listbox content
    def refresh_pet():
        pet_livestock_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for animal in profile_data.get('pet', []):
                animal_details = (
                    f"{animal['name']} | {animal['species']} | {animal['coloring']} | Location: {animal['location']} | "
                    f"Food/Water: {animal['food_water']} | Care: {animal['care']} | Vet: {animal['vet_contact']} | "
                    f"Placement: {animal['placement']}"
                )
                pet_livestock_listbox.insert(tk.END, animal_details)

    # Save pet/livestock details
    def save_pet_livestock():
        name = name_entry.get()
        species = species_entry.get()
        coloring = coloring_entry.get()
        location = location_entry.get()
        food_water = food_water_entry.get()
        care = care_entry.get()
        vet_contact = vet_contact_entry.get()
        placement = placement_entry.get()

        if name and species and location:
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'pet' not in profile_data:
                    profile_data['pet'] = []
                profile_data['pet'].append({
                    "name": name,
                    "species": species,
                    "coloring": coloring,
                    "location": location,
                    "food_water": food_water,
                    "care": care,
                    "vet_contact": vet_contact,
                    "placement": placement
                })
                # Clear the entry fields after saving
                name_entry.delete(0, tk.END)
                species_entry.delete(0, tk.END)
                coloring_entry.delete(0, tk.END)
                location_entry.delete(0, tk.END)
                food_water_entry.delete(0, tk.END)
                care_entry.delete(0, tk.END)
                vet_contact_entry.delete(0, tk.END)
                placement_entry.delete(0, tk.END)

                update_status_callback()  # Update the pets and livestock status label
                refresh_pet()  # Refresh the list display
                save_profiles(profiles)  # Save profiles to file
        else:
            messagebox.showwarning("Input Error", "Please fill all required fields (except optional fields).")

    # Add button to save animal
    tk.Button(scrollable_frame, text="Save Animal", command=save_pet_livestock).pack(pady=10)

    # Populate the listbox with existing pets/livestock
    refresh_pet()



def open_children_window(profile_name, update_status_callback):
    children_window = tk.Toplevel()
    children_window.title(f"Manage Children for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(children_window)
    scrollbar = tk.Scrollbar(children_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Fields for entering child details
    tk.Label(scrollable_frame, text="Child's Full Name:").pack(pady=5)
    name_entry = tk.Entry(scrollable_frame)
    name_entry.pack(pady=5)
    name_entry.focus_set()

    tk.Label(scrollable_frame, text="Date of Birth (YYYY-MM-DD):").pack(pady=5)
    dob_entry = tk.Entry(scrollable_frame)
    dob_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Birthplace:").pack(pady=5)
    birthplace_entry = tk.Entry(scrollable_frame)
    birthplace_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Relationship Type (e.g., Biological, Step, Adopted):").pack(pady=5)
    relationship_entry = tk.Entry(scrollable_frame)
    relationship_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Additional Notes:").pack(pady=5)
    notes_entry = tk.Entry(scrollable_frame)
    notes_entry.pack(pady=5)

    # Children list display
    children_listbox = tk.Listbox(scrollable_frame, height=10, width=70)
    children_listbox.pack(pady=10)

    # Refresh listbox content
    def refresh_children_list():
        children_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for child in profile_data.get('children', []):
                child_details = (
                    f"{child['name']} | {child['dob']} | {child['birthplace']} | "
                    f"{child['relationship']} | {child['notes']}"
                )
                children_listbox.insert(tk.END, child_details)

    # Save child details
    def save_child():
        name = name_entry.get()
        dob = dob_entry.get()
        birthplace = birthplace_entry.get()
        relationship = relationship_entry.get()
        notes = notes_entry.get()

        if name and dob and birthplace and relationship:
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'children' not in profile_data:
                    profile_data['children'] = []
                profile_data['children'].append({
                    "name": name,
                    "dob": dob,
                    "birthplace": birthplace,
                    "relationship": relationship,
                    "notes": notes
                })
                # Clear the entry fields after saving
                name_entry.delete(0, tk.END)
                dob_entry.delete(0, tk.END)
                birthplace_entry.delete(0, tk.END)
                relationship_entry.delete(0, tk.END)
                notes_entry.delete(0, tk.END)

                update_status_callback()  # Update the status label for this section
                refresh_children_list()  # Refresh the list display
                save_profiles(profiles)  # Save profiles to file
        else:
            messagebox.showwarning("Input Error", "Please fill all required fields except Notes (optional).")

    # Add button to save child
    tk.Button(scrollable_frame, text="Save Child", command=save_child).pack(pady=10)

    # Populate the listbox with existing children
    refresh_children_list()


def open_letter_to_loved_ones(profile_name, update_status_callback):
    letter_window = tk.Toplevel()
    letter_window.title(f"Letter to Loved Ones for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(letter_window)
    scrollbar = tk.Scrollbar(letter_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Fields for entering recipient details
    tk.Label(scrollable_frame, text="Recipient's Name:").pack(pady=5)
    name_entry = tk.Entry(scrollable_frame)
    name_entry.pack(pady=5)
    name_entry.focus_set()

    tk.Label(scrollable_frame, text="Recipient's Address:").pack(pady=5)
    address_entry = tk.Entry(scrollable_frame)
    address_entry.pack(pady=5)

    # Recipients list display
    recipients_listbox = tk.Listbox(scrollable_frame, height=10, width=70)
    recipients_listbox.pack(pady=10)

    # Refresh listbox content
    def refresh_recipients_list():
        recipients_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for recipient in profile_data.get('recipients', []):
                recipient_details = f"{recipient['name']} | {recipient['address']}"
                recipients_listbox.insert(tk.END, recipient_details)

    # Save recipient details
    def save_recipient():
        name = name_entry.get()
        address = address_entry.get()

        if name and address:
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'recipients' not in profile_data:
                    profile_data['recipients'] = []
                profile_data['recipients'].append({"name": name, "address": address})
                # Clear the entry fields after saving
                name_entry.delete(0, tk.END)
                address_entry.delete(0, tk.END)

                update_status_callback()  # Update the status label for this section
                refresh_recipients_list()  # Refresh the list display
                save_profiles(profiles)  # Save profiles to file
        else:
            messagebox.showwarning("Input Error", "Please fill out both fields.")

    # Add button to save recipient
    tk.Button(scrollable_frame, text="Add Recipient", command=save_recipient).pack(pady=10)

    # Button to proceed to letter writing
    def open_letter_writing_window():
        # Close the current window
        letter_window.destroy()

        # Open the letter writing window
        letter_writing_window = tk.Toplevel()
        letter_writing_window.title(f"Write Letter for {profile_name}")

        tk.Label(letter_writing_window, text="Write Your Letter Below:").pack(pady=10)

        # Textbox for writing the letter
        letter_textbox = tk.Text(letter_writing_window, height=20, width=70)
        letter_textbox.pack(pady=10)

        # Populate the letter content if it exists
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data and 'letter_content' in profile_data:
            letter_textbox.insert("1.0", profile_data['letter_content'])

        # Save the letter content
        def save_letter():
            letter_content = letter_textbox.get("1.0", tk.END).strip()
            if profile_data:
                profile_data['letter_content'] = letter_content
                save_profiles(profiles)  # Save profiles to file
                update_status_callback()  # Update the status label for this section
                messagebox.showinfo("Success", "Letter content saved successfully!")
                letter_writing_window.destroy()

        tk.Button(letter_writing_window, text="Save Letter", command=save_letter).pack(pady=10)

    tk.Button(scrollable_frame, text="Write Letter to Loved Ones", command=open_letter_writing_window).pack(pady=10)

    # Populate the listbox with existing recipients
    refresh_recipients_list()


def open_dependents_window(profile_name, update_status_callback):
    dependents_window = tk.Toplevel()
    dependents_window.title(f"Manage Dependents for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(dependents_window)
    scrollbar = tk.Scrollbar(dependents_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Fields for entering dependent details
    tk.Label(scrollable_frame, text="Dependent's Full Name:").pack(pady=5)
    name_entry = tk.Entry(scrollable_frame)
    name_entry.pack(pady=5)
    name_entry.focus_set()

    tk.Label(scrollable_frame, text="Relationship (e.g., Parent, Sibling):").pack(pady=5)
    relationship_entry = tk.Entry(scrollable_frame)
    relationship_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Age:").pack(pady=5)
    age_entry = tk.Entry(scrollable_frame)
    age_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Reason for Dependence:").pack(pady=5)
    reason_entry = tk.Entry(scrollable_frame)
    reason_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Type of Support Provided (e.g., Financial, Emotional):").pack(pady=5)
    support_entry = tk.Entry(scrollable_frame)
    support_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Additional Notes:").pack(pady=5)
    notes_entry = tk.Entry(scrollable_frame)
    notes_entry.pack(pady=5)

    # Dependents list display
    dependents_listbox = tk.Listbox(scrollable_frame, height=10, width=70)
    dependents_listbox.pack(pady=10)

    # Refresh listbox content
    def refresh_dependents_list():
        dependents_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for dependent in profile_data.get('dependents', []):
                dependent_details = (
                    f"{dependent['name']} | {dependent['relationship']} | Age: {dependent['age']} | "
                    f"Reason: {dependent['reason']} | Support: {dependent['support']} | Notes: {dependent['notes']}"
                )
                dependents_listbox.insert(tk.END, dependent_details)

    # Save dependent details
    def save_dependent():
        name = name_entry.get()
        relationship = relationship_entry.get()
        age = age_entry.get()
        reason = reason_entry.get()
        support = support_entry.get()
        notes = notes_entry.get()

        if name and relationship and age and reason and support:
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'dependents' not in profile_data:
                    profile_data['dependents'] = []
                profile_data['dependents'].append({
                    "name": name,
                    "relationship": relationship,
                    "age": age,
                    "reason": reason,
                    "support": support,
                    "notes": notes
                })
                # Clear the entry fields after saving
                name_entry.delete(0, tk.END)
                relationship_entry.delete(0, tk.END)
                age_entry.delete(0, tk.END)
                reason_entry.delete(0, tk.END)
                support_entry.delete(0, tk.END)
                notes_entry.delete(0, tk.END)

                update_status_callback()  # Update the status label for this section
                refresh_dependents_list()  # Refresh the list display
                save_profiles(profiles)  # Save profiles to file
        else:
            messagebox.showwarning("Input Error", "Please fill all required fields except Notes (optional).")

    # Add button to save dependent
    tk.Button(scrollable_frame, text="Save Dependent", command=save_dependent).pack(pady=10)

    # Populate the listbox with existing dependents
    refresh_dependents_list()


import tkinter as tk
from tkinter import messagebox

def open_business_interests_window(profile_name, update_status_callback):
    business_window = tk.Toplevel()
    business_window.title(f"Manage Business Interests for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(business_window)
    scrollbar = tk.Scrollbar(business_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Fields for entering business details
    tk.Label(scrollable_frame, text="Business Name:").pack(pady=5)
    business_name_entry = tk.Entry(scrollable_frame)
    business_name_entry.pack(pady=5)
    business_name_entry.focus_set()

    tk.Label(scrollable_frame, text="Type of Business:").pack(pady=5)
    business_type_entry = tk.Entry(scrollable_frame)
    business_type_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Ownership Percentage:").pack(pady=5)
    ownership_entry = tk.Entry(scrollable_frame)
    ownership_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Start Date (YYYY-MM-DD):").pack(pady=5)
    start_date_entry = tk.Entry(scrollable_frame)
    start_date_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Location:").pack(pady=5)
    location_entry = tk.Entry(scrollable_frame)
    location_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Additional Notes:").pack(pady=5)
    notes_entry = tk.Entry(scrollable_frame)
    notes_entry.pack(pady=5)

    # Disposition of Entire Business
    tk.Label(scrollable_frame, text="Disposition of Entire Business:").pack(pady=5)
    entire_business_var = tk.StringVar(value="None")
    for option in ["Continue", "Transfer", "Sell", "Liquidate"]:
        tk.Radiobutton(scrollable_frame, text=option, variable=entire_business_var, value=option).pack(anchor="w")

    # Disposition of My Interest
    tk.Label(scrollable_frame, text="Disposition of My Interest:").pack(pady=5)
    my_interest_var = tk.StringVar(value="None")
    for option in ["Transfer", "Sell", "Liquidate"]:
        tk.Radiobutton(scrollable_frame, text=option, variable=my_interest_var, value=option).pack(anchor="w")

    # Contact Information for Key Individuals
    tk.Label(scrollable_frame, text="Attorney Name:").pack(pady=5)
    attorney_entry = tk.Entry(scrollable_frame)
    attorney_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Accountant Name:").pack(pady=5)
    accountant_entry = tk.Entry(scrollable_frame)
    accountant_entry.pack(pady=5)

    # Disposition Notes
    tk.Label(scrollable_frame, text="Disposition Notes:").pack(pady=5)
    disposition_notes_entry = tk.Entry(scrollable_frame)
    disposition_notes_entry.pack(pady=5)

    # Business list display
    business_listbox = tk.Listbox(scrollable_frame, height=10, width=70)
    business_listbox.pack(pady=10)

    # Refresh listbox content
    def refresh_business_list():
        business_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for business in profile_data.get('business_interests', []):
                business_details = (
                    f"{business['name']} | {business['type']} | {business['ownership']}% | "
                    f"Start Date: {business['start_date']} | Location: {business['location']} | "
                    f"Disposition: {business['entire_business']} | "
                    f"My Interest: {business['my_interest']} | Notes: {business['notes']}"
                )
                business_listbox.insert(tk.END, business_details)

    # Save business details
    def save_business():
        name = business_name_entry.get()
        business_type = business_type_entry.get()
        ownership = ownership_entry.get()
        start_date = start_date_entry.get()
        location = location_entry.get()
        notes = notes_entry.get()
        entire_business = entire_business_var.get()
        my_interest = my_interest_var.get()
        attorney = attorney_entry.get()
        accountant = accountant_entry.get()
        disposition_notes = disposition_notes_entry.get()

        if name and business_type and ownership and start_date and location:
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'business_interests' not in profile_data:
                    profile_data['business_interests'] = []
                profile_data['business_interests'].append({
                    "name": name,
                    "type": business_type,
                    "ownership": ownership,
                    "start_date": start_date,
                    "location": location,
                    "notes": notes,
                    "entire_business": entire_business,
                    "my_interest": my_interest,
                    "attorney": attorney,
                    "accountant": accountant,
                    "disposition_notes": disposition_notes
                })
                # Clear the entry fields after saving
                business_name_entry.delete(0, tk.END)
                business_type_entry.delete(0, tk.END)
                ownership_entry.delete(0, tk.END)
                start_date_entry.delete(0, tk.END)
                location_entry.delete(0, tk.END)
                notes_entry.delete(0, tk.END)
                attorney_entry.delete(0, tk.END)
                accountant_entry.delete(0, tk.END)
                disposition_notes_entry.delete(0, tk.END)

                update_status_callback()  # Update the status label for this section
                refresh_business_list()  # Refresh the list display
                save_profiles(profiles)  # Save profiles to file
        else:
            messagebox.showwarning("Input Error", "Please fill all required fields except Notes (optional).")

    # Add button to save business interest
    tk.Button(scrollable_frame, text="Save Business Interest", command=save_business).pack(pady=10)

    # Populate the listbox with existing business interests
    refresh_business_list()



def open_employment_window(profile_name, update_status_callback):
    employment_window = tk.Toplevel()
    employment_window.title(f"Manage Employment for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(employment_window)
    scrollbar = tk.Scrollbar(employment_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Fields for entering employment details
    tk.Label(scrollable_frame, text="Employer Name:").pack(pady=5)
    employer_entry = tk.Entry(scrollable_frame)
    employer_entry.pack(pady=5)
    employer_entry.focus_set()

    tk.Label(scrollable_frame, text="Position/Title:").pack(pady=5)
    position_entry = tk.Entry(scrollable_frame)
    position_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Start Date (YYYY-MM-DD):").pack(pady=5)
    start_date_entry = tk.Entry(scrollable_frame)
    start_date_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="End Date (YYYY-MM-DD) or 'Present':").pack(pady=5)
    end_date_entry = tk.Entry(scrollable_frame)
    end_date_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Job Location:").pack(pady=5)
    location_entry = tk.Entry(scrollable_frame)
    location_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Additional Notes:").pack(pady=5)
    notes_entry = tk.Entry(scrollable_frame)
    notes_entry.pack(pady=5)

    # Employment list display
    employment_listbox = tk.Listbox(scrollable_frame, height=10, width=70)
    employment_listbox.pack(pady=10)

    # Refresh listbox content
    def refresh_employment_list():
        employment_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for job in profile_data.get('employment', []):
                job_details = (
                    f"{job['employer']} | {job['position']} | {job['start_date']} - {job['end_date']} | "
                    f"Location: {job['location']} | Notes: {job['notes']}"
                )
                employment_listbox.insert(tk.END, job_details)

    # Save employment details
    def save_employment():
        employer = employer_entry.get()
        position = position_entry.get()
        start_date = start_date_entry.get()
        end_date = end_date_entry.get()
        location = location_entry.get()
        notes = notes_entry.get()

        if employer and position and start_date and end_date and location:
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'employment' not in profile_data:
                    profile_data['employment'] = []
                profile_data['employment'].append({
                    "employer": employer,
                    "position": position,
                    "start_date": start_date,
                    "end_date": end_date,
                    "location": location,
                    "notes": notes
                })
                # Clear the entry fields after saving
                employer_entry.delete(0, tk.END)
                position_entry.delete(0, tk.END)
                start_date_entry.delete(0, tk.END)
                end_date_entry.delete(0, tk.END)
                location_entry.delete(0, tk.END)
                notes_entry.delete(0, tk.END)

                update_status_callback()  # Update the status label for this section
                refresh_employment_list()  # Refresh the list display
                save_profiles(profiles)  # Save profiles to file
        else:
            messagebox.showwarning("Input Error", "Please fill all required fields except Notes (optional).")

    # Add button to save employment
    tk.Button(scrollable_frame, text="Save Employment", command=save_employment).pack(pady=10)

    # Populate the listbox with existing employment records
    refresh_employment_list()


def open_memberships_window(profile_name, update_status_callback):
    memberships_window = tk.Toplevel()
    memberships_window.title(f"Manage Memberships for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(memberships_window)
    scrollbar = tk.Scrollbar(memberships_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Fields for entering membership details
    tk.Label(scrollable_frame, text="Membership Name:").pack(pady=5)
    membership_name_entry = tk.Entry(scrollable_frame)
    membership_name_entry.pack(pady=5)
    membership_name_entry.focus_set()

    tk.Label(scrollable_frame, text="Organization Name:").pack(pady=5)
    organization_entry = tk.Entry(scrollable_frame)
    organization_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Membership Start Date (YYYY-MM-DD):").pack(pady=5)
    start_date_entry = tk.Entry(scrollable_frame)
    start_date_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Membership End Date (YYYY-MM-DD) (Optional):").pack(pady=5)
    end_date_entry = tk.Entry(scrollable_frame)
    end_date_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Membership Role or Position:").pack(pady=5)
    role_entry = tk.Entry(scrollable_frame)
    role_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Additional Notes:").pack(pady=5)
    notes_entry = tk.Entry(scrollable_frame)
    notes_entry.pack(pady=5)

    # Membership list display
    memberships_listbox = tk.Listbox(scrollable_frame, height=10, width=70)
    memberships_listbox.pack(pady=10)

    # Refresh listbox content
    def refresh_memberships_list():
        memberships_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for membership in profile_data.get('memberships', []):
                membership_details = (
                    f"{membership['name']} | {membership['organization']} | Start: {membership['start_date']} | "
                    f"End: {membership['end_date']} | Role: {membership['role']} | Notes: {membership['notes']}"
                )
                memberships_listbox.insert(tk.END, membership_details)

    # Save membership details
    def save_membership():
        name = membership_name_entry.get()
        organization = organization_entry.get()
        start_date = start_date_entry.get()
        end_date = end_date_entry.get()
        role = role_entry.get()
        notes = notes_entry.get()

        if name and organization and start_date and role:
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'memberships' not in profile_data:
                    profile_data['memberships'] = []
                profile_data['memberships'].append({
                    "name": name,
                    "organization": organization,
                    "start_date": start_date,
                    "end_date": end_date,
                    "role": role,
                    "notes": notes
                })
                # Clear the entry fields after saving
                membership_name_entry.delete(0, tk.END)
                organization_entry.delete(0, tk.END)
                start_date_entry.delete(0, tk.END)
                end_date_entry.delete(0, tk.END)
                role_entry.delete(0, tk.END)
                notes_entry.delete(0, tk.END)

                update_status_callback()  # Update the status label for this section
                refresh_memberships_list()  # Refresh the list display
                save_profiles(profiles)  # Save profiles to file
        else:
            messagebox.showwarning("Input Error", "Please fill all required fields except Notes and End Date (optional).")

    # Add button to save membership
    tk.Button(scrollable_frame, text="Save Membership", command=save_membership).pack(pady=10)

    # Populate the listbox with existing memberships
    refresh_memberships_list()

def open_service_providers_window(profile_name, update_status_callback):
    service_providers_window = tk.Toplevel()
    service_providers_window.title(f"Manage Service Providers for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(service_providers_window)
    scrollbar = tk.Scrollbar(service_providers_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Fields for entering service provider details
    tk.Label(scrollable_frame, text="Service Provider Name:").pack(pady=5)
    provider_name_entry = tk.Entry(scrollable_frame)
    provider_name_entry.pack(pady=5)
    provider_name_entry.focus_set()

    tk.Label(scrollable_frame, text="Service Type (e.g., Electrician, Plumber, Lawyer):").pack(pady=5)
    service_type_entry = tk.Entry(scrollable_frame)
    service_type_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Contact Number:").pack(pady=5)
    contact_number_entry = tk.Entry(scrollable_frame)
    contact_number_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Email Address (Optional):").pack(pady=5)
    email_entry = tk.Entry(scrollable_frame)
    email_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Address (Optional):").pack(pady=5)
    address_entry = tk.Entry(scrollable_frame)
    address_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Additional Notes:").pack(pady=5)
    notes_entry = tk.Entry(scrollable_frame)
    notes_entry.pack(pady=5)

    # Service provider list display
    service_providers_listbox = tk.Listbox(scrollable_frame, height=10, width=70)
    service_providers_listbox.pack(pady=10)

    # Refresh listbox content
    def refresh_service_providers_list():
        service_providers_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for provider in profile_data.get('service_providers', []):
                provider_details = (
                    f"{provider['name']} | {provider['service_type']} | {provider['contact_number']} | "
                    f"{provider['email']} | {provider['address']} | {provider['notes']}"
                )
                service_providers_listbox.insert(tk.END, provider_details)

    # Save service provider details
    def save_service_provider():
        name = provider_name_entry.get()
        service_type = service_type_entry.get()
        contact_number = contact_number_entry.get()
        email = email_entry.get()
        address = address_entry.get()
        notes = notes_entry.get()

        if name and service_type and contact_number:
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'service_providers' not in profile_data:
                    profile_data['service_providers'] = []
                profile_data['service_providers'].append({
                    "name": name,
                    "service_type": service_type,
                    "contact_number": contact_number,
                    "email": email,
                    "address": address,
                    "notes": notes
                })
                # Clear the entry fields after saving
                provider_name_entry.delete(0, tk.END)
                service_type_entry.delete(0, tk.END)
                contact_number_entry.delete(0, tk.END)
                email_entry.delete(0, tk.END)
                address_entry.delete(0, tk.END)
                notes_entry.delete(0, tk.END)

                update_status_callback()  # Update the status label for this section
                refresh_service_providers_list()  # Refresh the list display
                save_profiles(profiles)  # Save profiles to file
        else:
            messagebox.showwarning("Input Error", "Please fill all required fields except Notes, Email, and Address (optional).")

    # Add button to save service provider
    tk.Button(scrollable_frame, text="Save Service Provider", command=save_service_provider).pack(pady=10)

    # Populate the listbox with existing service providers
    refresh_service_providers_list()


def open_health_care_directives_window(profile_name, update_status_callback):
    health_care_window = tk.Toplevel()
    health_care_window.title(f"Manage Health Care Directives for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(health_care_window)
    scrollbar = tk.Scrollbar(health_care_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Fields for entering health care directive details
    tk.Label(scrollable_frame, text="Directive Title:").pack(pady=5)
    directive_title_entry = tk.Entry(scrollable_frame)
    directive_title_entry.pack(pady=5)
    directive_title_entry.focus_set()

    tk.Label(scrollable_frame, text="Type of Directive (e.g., Living Will, DNR, Medical POA):").pack(pady=5)
    directive_type_entry = tk.Entry(scrollable_frame)
    directive_type_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Date of Creation (YYYY-MM-DD):").pack(pady=5)
    creation_date_entry = tk.Entry(scrollable_frame)
    creation_date_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Document Location (e.g., Physical Address, Digital File Path):").pack(pady=5)
    document_location_entry = tk.Entry(scrollable_frame)
    document_location_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Additional Notes:").pack(pady=5)
    notes_entry = tk.Entry(scrollable_frame)
    notes_entry.pack(pady=5)

    # Health care directives list display
    directives_listbox = tk.Listbox(scrollable_frame, height=10, width=70)
    directives_listbox.pack(pady=10)

    # Refresh listbox content
    def refresh_directives_list():
        directives_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for directive in profile_data.get('health_care_directives', []):
                directive_details = (
                    f"{directive['title']} | {directive['type']} | {directive['creation_date']} | "
                    f"{directive['document_location']} | {directive['notes']}"
                )
                directives_listbox.insert(tk.END, directive_details)

    # Save health care directive details
    def save_directive():
        title = directive_title_entry.get()
        directive_type = directive_type_entry.get()
        creation_date = creation_date_entry.get()
        document_location = document_location_entry.get()
        notes = notes_entry.get()

        if title and directive_type and creation_date and document_location:
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'health_care_directives' not in profile_data:
                    profile_data['health_care_directives'] = []
                profile_data['health_care_directives'].append({
                    "title": title,
                    "type": directive_type,
                    "creation_date": creation_date,
                    "document_location": document_location,
                    "notes": notes
                })
                # Clear the entry fields after saving
                directive_title_entry.delete(0, tk.END)
                directive_type_entry.delete(0, tk.END)
                creation_date_entry.delete(0, tk.END)
                document_location_entry.delete(0, tk.END)
                notes_entry.delete(0, tk.END)

                update_status_callback()  # Update the status label for this section
                refresh_directives_list()  # Refresh the list display
                save_profiles(profiles)  # Save profiles to file
        else:
            messagebox.showwarning(
                "Input Error", "Please fill all required fields except Notes (optional)."
            )

    # Add button to save health care directive
    tk.Button(scrollable_frame, text="Save Directive", command=save_directive).pack(pady=10)

    # Populate the listbox with existing directives
    refresh_directives_list()

def open_power_of_attorney_window(profile_name, update_status_callback):
    poa_window = tk.Toplevel()
    poa_window.title(f"Manage Power of Attorney for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(poa_window)
    scrollbar = tk.Scrollbar(poa_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Fields for entering Power of Attorney details
    tk.Label(scrollable_frame, text="Attorney-In-Fact (Full Name):").pack(pady=5)
    name_entry = tk.Entry(scrollable_frame)
    name_entry.pack(pady=5)
    name_entry.focus_set()

    tk.Label(scrollable_frame, text="Type of Power of Attorney (e.g., General, Financial, Medical):").pack(pady=5)
    type_entry = tk.Entry(scrollable_frame)
    type_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Date of Execution (YYYY-MM-DD):").pack(pady=5)
    execution_date_entry = tk.Entry(scrollable_frame)
    execution_date_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Document Location (e.g., Physical Address, Digital File Path):").pack(pady=5)
    document_location_entry = tk.Entry(scrollable_frame)
    document_location_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Additional Notes:").pack(pady=5)
    notes_entry = tk.Entry(scrollable_frame)
    notes_entry.pack(pady=5)

    # Listbox for displaying Power of Attorney entries
    poa_listbox = tk.Listbox(scrollable_frame, height=10, width=70)
    poa_listbox.pack(pady=10)

    # Refresh listbox content
    def refresh_poa_list():
        poa_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for poa in profile_data.get('power_of_attorney', []):
                poa_details = (
                    f"{poa['name']} | {poa['type']} | {poa['execution_date']} | "
                    f"{poa['document_location']} | {poa['notes']}"
                )
                poa_listbox.insert(tk.END, poa_details)

    # Save Power of Attorney details
    def save_poa():
        name = name_entry.get()
        poa_type = type_entry.get()
        execution_date = execution_date_entry.get()
        document_location = document_location_entry.get()
        notes = notes_entry.get()

        if name and poa_type and execution_date and document_location:
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'power_of_attorney' not in profile_data:
                    profile_data['power_of_attorney'] = []
                profile_data['power_of_attorney'].append({
                    "name": name,
                    "type": poa_type,
                    "execution_date": execution_date,
                    "document_location": document_location,
                    "notes": notes
                })
                # Clear the entry fields after saving
                name_entry.delete(0, tk.END)
                type_entry.delete(0, tk.END)
                execution_date_entry.delete(0, tk.END)
                document_location_entry.delete(0, tk.END)
                notes_entry.delete(0, tk.END)

                update_status_callback()  # Update the status label for this section
                refresh_poa_list()  # Refresh the list display
                save_profiles(profiles)  # Save profiles to file
        else:
            messagebox.showwarning(
                "Input Error", "Please fill all required fields except Notes (optional)."
            )

    # Add button to save Power of Attorney
    tk.Button(scrollable_frame, text="Save Power of Attorney", command=save_poa).pack(pady=10)

    # Populate the listbox with existing Power of Attorney entries
    refresh_poa_list()

def open_organ_donation_window(profile_name, update_status_callback):
    organ_donation_window = tk.Toplevel()
    organ_donation_window.title(f"Manage Organ Donation for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(organ_donation_window)
    scrollbar = tk.Scrollbar(organ_donation_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Fields for entering organ donation details
    tk.Label(scrollable_frame, text="Are you registered as an organ donor? (Yes/No):").pack(pady=5)
    donor_status_entry = tk.Entry(scrollable_frame)
    donor_status_entry.pack(pady=5)
    donor_status_entry.focus_set()

    tk.Label(scrollable_frame, text="Registration Number or Details (if applicable):").pack(pady=5)
    registration_number_entry = tk.Entry(scrollable_frame)
    registration_number_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Specific Organs to Donate (if any):").pack(pady=5)
    specific_organs_entry = tk.Entry(scrollable_frame)
    specific_organs_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Additional Notes or Preferences:").pack(pady=5)
    notes_entry = tk.Entry(scrollable_frame)
    notes_entry.pack(pady=5)

    # Listbox for displaying organ donation details
    organ_donation_listbox = tk.Listbox(scrollable_frame, height=10, width=70)
    organ_donation_listbox.pack(pady=10)

    # Refresh listbox content
    def refresh_organ_donation_list():
        organ_donation_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for donation in profile_data.get('organ_donation', []):
                donation_details = (
                    f"Donor Status: {donation['donor_status']} | Registration: {donation['registration_number']} | "
                    f"Organs: {donation['specific_organs']} | Notes: {donation['notes']}"
                )
                organ_donation_listbox.insert(tk.END, donation_details)

    # Save organ donation details
    def save_organ_donation():
        donor_status = donor_status_entry.get()
        registration_number = registration_number_entry.get()
        specific_organs = specific_organs_entry.get()
        notes = notes_entry.get()

        if donor_status.lower() in ["yes", "no"]:
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'organ_donation' not in profile_data:
                    profile_data['organ_donation'] = []
                profile_data['organ_donation'].append({
                    "donor_status": donor_status.capitalize(),
                    "registration_number": registration_number,
                    "specific_organs": specific_organs,
                    "notes": notes
                })
                # Clear the entry fields after saving
                donor_status_entry.delete(0, tk.END)
                registration_number_entry.delete(0, tk.END)
                specific_organs_entry.delete(0, tk.END)
                notes_entry.delete(0, tk.END)

                update_status_callback()  # Update the status label for this section
                refresh_organ_donation_list()  # Refresh the list display
                save_profiles(profiles)  # Save profiles to file
        else:
            messagebox.showwarning(
                "Input Error", "Please enter 'Yes' or 'No' for donor status."
            )

    # Add button to save organ donation details
    tk.Button(scrollable_frame, text="Save Organ Donation", command=save_organ_donation).pack(pady=10)

    # Populate the listbox with existing organ donation entries
    refresh_organ_donation_list()

def open_burial_cremation_window(profile_name, update_status_callback):
    burial_cremation_window = tk.Toplevel()
    burial_cremation_window.title(f"Manage Burial or Cremation Preferences for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(burial_cremation_window)
    scrollbar = tk.Scrollbar(burial_cremation_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Fields for entering burial or cremation preferences
    tk.Label(scrollable_frame, text="Preferred Option (Burial/Cremation):").pack(pady=5)
    preference_entry = tk.Entry(scrollable_frame)
    preference_entry.pack(pady=5)
    preference_entry.focus_set()

    tk.Label(scrollable_frame, text="Location or Cemetery Name:").pack(pady=5)
    location_entry = tk.Entry(scrollable_frame)
    location_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Special Instructions or Wishes:").pack(pady=5)
    special_instructions_entry = tk.Entry(scrollable_frame)
    special_instructions_entry.pack(pady=5)

    # Listbox for displaying burial or cremation preferences
    burial_cremation_listbox = tk.Listbox(scrollable_frame, height=10, width=70)
    burial_cremation_listbox.pack(pady=10)

    # Refresh listbox content
    def refresh_burial_cremation_list():
        burial_cremation_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for option in profile_data.get('burial_cremation', []):
                option_details = (
                    f"Preference: {option['preference']} | Location: {option['location']} | "
                    f"Instructions: {option['instructions']}"
                )
                burial_cremation_listbox.insert(tk.END, option_details)

    # Save burial or cremation preferences
    def save_burial_cremation():
        preference = preference_entry.get().strip()
        location = location_entry.get().strip()
        instructions = special_instructions_entry.get().strip()

        if preference.lower() in ["burial", "cremation"]:
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'burial_cremation' not in profile_data:
                    profile_data['burial_cremation'] = []
                profile_data['burial_cremation'].append({
                    "preference": preference.capitalize(),
                    "location": location,
                    "instructions": instructions
                })
                # Clear the entry fields after saving
                preference_entry.delete(0, tk.END)
                location_entry.delete(0, tk.END)
                special_instructions_entry.delete(0, tk.END)

                update_status_callback()  # Update the status label for this section
                refresh_burial_cremation_list()  # Refresh the list display
                save_profiles(profiles)  # Save profiles to file
        else:
            messagebox.showwarning(
                "Input Error", "Please enter 'Burial' or 'Cremation' as the preferred option."
            )

    # Add button to save burial or cremation preferences
    tk.Button(scrollable_frame, text="Save Preferences", command=save_burial_cremation).pack(pady=10)

    # Populate the listbox with existing burial or cremation entries
    refresh_burial_cremation_list()

def open_funeral_services_window(profile_name, update_status_callback):
    funeral_services_window = tk.Toplevel()
    funeral_services_window.title(f"Manage Funeral Services for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(funeral_services_window)
    scrollbar = tk.Scrollbar(funeral_services_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Fields for entering funeral service details
    tk.Label(scrollable_frame, text="Funeral Home or Provider Name:").pack(pady=5)
    provider_name_entry = tk.Entry(scrollable_frame)
    provider_name_entry.pack(pady=5)
    provider_name_entry.focus_set()

    tk.Label(scrollable_frame, text="Address:").pack(pady=5)
    address_entry = tk.Entry(scrollable_frame)
    address_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Contact Number:").pack(pady=5)
    contact_number_entry = tk.Entry(scrollable_frame)
    contact_number_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Type of Service (e.g., Memorial, Viewing, Religious Ceremony):").pack(pady=5)
    service_type_entry = tk.Entry(scrollable_frame)
    service_type_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Special Instructions or Notes:").pack(pady=5)
    special_instructions_entry = tk.Entry(scrollable_frame)
    special_instructions_entry.pack(pady=5)

    # Listbox for displaying funeral service preferences
    funeral_services_listbox = tk.Listbox(scrollable_frame, height=10, width=70)
    funeral_services_listbox.pack(pady=10)

    # Refresh listbox content
    def refresh_funeral_services_list():
        funeral_services_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for service in profile_data.get('funeral_services', []):
                service_details = (
                    f"Provider: {service['provider']} | Address: {service['address']} | "
                    f"Contact: {service['contact']} | Type: {service['type']} | Notes: {service['notes']}"
                )
                funeral_services_listbox.insert(tk.END, service_details)

    # Save funeral service details
    def save_funeral_service():
        provider = provider_name_entry.get().strip()
        address = address_entry.get().strip()
        contact = contact_number_entry.get().strip()
        service_type = service_type_entry.get().strip()
        notes = special_instructions_entry.get().strip()

        if provider and service_type:
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'funeral_services' not in profile_data:
                    profile_data['funeral_services'] = []
                profile_data['funeral_services'].append({
                    "provider": provider,
                    "address": address,
                    "contact": contact,
                    "type": service_type,
                    "notes": notes
                })
                # Clear the entry fields after saving
                provider_name_entry.delete(0, tk.END)
                address_entry.delete(0, tk.END)
                contact_number_entry.delete(0, tk.END)
                service_type_entry.delete(0, tk.END)
                special_instructions_entry.delete(0, tk.END)

                update_status_callback()  # Update the status label for this section
                refresh_funeral_services_list()  # Refresh the list display
                save_profiles(profiles)  # Save profiles to file
        else:
            messagebox.showwarning(
                "Input Error", "Please fill in the Provider Name and Service Type fields."
            )

    # Add button to save funeral service details
    tk.Button(scrollable_frame, text="Save Funeral Service", command=save_funeral_service).pack(pady=10)

    # Populate the listbox with existing funeral service entries
    refresh_funeral_services_list()

def open_obituary_window(profile_name, update_status_callback):
    obituary_window = tk.Toplevel()
    obituary_window.title(f"Manage Obituary for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(obituary_window)
    scrollbar = tk.Scrollbar(obituary_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Fields for entering obituary details
    tk.Label(scrollable_frame, text="Obituary Title:").pack(pady=5)
    title_entry = tk.Entry(scrollable_frame, width=60)
    title_entry.pack(pady=5)
    title_entry.focus_set()

    tk.Label(scrollable_frame, text="Obituary Content:").pack(pady=5)
    content_text = tk.Text(scrollable_frame, height=15, width=70, wrap="word")
    content_text.pack(pady=5)

    # Obituary list display
    obituary_listbox = tk.Listbox(scrollable_frame, height=10, width=70)
    obituary_listbox.pack(pady=10)

    # Refresh listbox content
    def refresh_obituary_list():
        obituary_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for obituary in profile_data.get('obituaries', []):
                obituary_details = f"Title: {obituary['title']} | Content: {obituary['content'][:50]}..."
                obituary_listbox.insert(tk.END, obituary_details)

    # Save obituary details
    def save_obituary():
        title = title_entry.get().strip()
        content = content_text.get("1.0", tk.END).strip()

        if title and content:
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'obituaries' not in profile_data:
                    profile_data['obituaries'] = []
                profile_data['obituaries'].append({
                    "title": title,
                    "content": content
                })
                # Clear the entry fields after saving
                title_entry.delete(0, tk.END)
                content_text.delete("1.0", tk.END)

                update_status_callback()  # Update the status label for this section
                refresh_obituary_list()  # Refresh the list display
                save_profiles(profiles)  # Save profiles to file
        else:
            messagebox.showwarning("Input Error", "Please fill in both the title and the content.")

    # Add button to save obituary
    tk.Button(scrollable_frame, text="Save Obituary", command=save_obituary).pack(pady=10)

    # Populate the listbox with existing obituary entries
    refresh_obituary_list()


def open_will_and_trust_window(profile_name, update_status_callback):
    will_trust_window = tk.Toplevel()
    will_trust_window.title(f"Manage Will and Trust for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(will_trust_window)
    scrollbar = tk.Scrollbar(will_trust_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Fields for entering will and trust details
    tk.Label(scrollable_frame, text="Will Title:").pack(pady=5)
    will_title_entry = tk.Entry(scrollable_frame, width=60)
    will_title_entry.pack(pady=5)
    will_title_entry.focus_set()

    tk.Label(scrollable_frame, text="Executor Name:").pack(pady=5)
    executor_name_entry = tk.Entry(scrollable_frame, width=60)
    executor_name_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Beneficiaries (Comma-separated):").pack(pady=5)
    beneficiaries_entry = tk.Entry(scrollable_frame, width=60)
    beneficiaries_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Trust Details:").pack(pady=5)
    trust_details_text = tk.Text(scrollable_frame, height=10, width=70, wrap="word")
    trust_details_text.pack(pady=5)

    # Will and trust list display
    will_trust_listbox = tk.Listbox(scrollable_frame, height=10, width=70)
    will_trust_listbox.pack(pady=10)

    # Refresh listbox content
    def refresh_will_trust_list():
        will_trust_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for entry in profile_data.get('wills_and_trusts', []):
                entry_details = (
                    f"Will: {entry['will_title']} | Executor: {entry['executor_name']} | "
                    f"Beneficiaries: {entry['beneficiaries'][:50]} | Trust: {entry['trust_details'][:50]}..."
                )
                will_trust_listbox.insert(tk.END, entry_details)

    # Save will and trust details
    def save_will_trust():
        will_title = will_title_entry.get().strip()
        executor_name = executor_name_entry.get().strip()
        beneficiaries = beneficiaries_entry.get().strip()
        trust_details = trust_details_text.get("1.0", tk.END).strip()

        if will_title and executor_name and beneficiaries and trust_details:
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'wills_and_trusts' not in profile_data:
                    profile_data['wills_and_trusts'] = []
                profile_data['wills_and_trusts'].append({
                    "will_title": will_title,
                    "executor_name": executor_name,
                    "beneficiaries": beneficiaries,
                    "trust_details": trust_details
                })
                # Clear the entry fields after saving
                will_title_entry.delete(0, tk.END)
                executor_name_entry.delete(0, tk.END)
                beneficiaries_entry.delete(0, tk.END)
                trust_details_text.delete("1.0", tk.END)

                update_status_callback()  # Update the status label for this section
                refresh_will_trust_list()  # Refresh the list display
                save_profiles(profiles)  # Save profiles to file
        else:
            messagebox.showwarning("Input Error", "Please fill in all fields.")

    # Add button to save will and trust
    tk.Button(scrollable_frame, text="Save Will and Trust", command=save_will_trust).pack(pady=10)

    # Populate the listbox with existing will and trust entries
    refresh_will_trust_list()


def open_insurance_window(profile_name, update_status_callback):
    insurance_window = tk.Toplevel()
    insurance_window.title(f"Manage Insurance for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(insurance_window)
    scrollbar = tk.Scrollbar(insurance_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Fields for entering insurance details
    tk.Label(scrollable_frame, text="Insurance Type (e.g., Life, Health, Auto):").pack(pady=5)
    insurance_type_entry = tk.Entry(scrollable_frame, width=60)
    insurance_type_entry.pack(pady=5)
    insurance_type_entry.focus_set()

    tk.Label(scrollable_frame, text="Policy Number:").pack(pady=5)
    policy_number_entry = tk.Entry(scrollable_frame, width=60)
    policy_number_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Provider Name:").pack(pady=5)
    provider_name_entry = tk.Entry(scrollable_frame, width=60)
    provider_name_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Coverage Details:").pack(pady=5)
    coverage_details_text = tk.Text(scrollable_frame, height=6, width=70, wrap="word")
    coverage_details_text.pack(pady=5)

    tk.Label(scrollable_frame, text="Beneficiaries (Comma-separated):").pack(pady=5)
    beneficiaries_entry = tk.Entry(scrollable_frame, width=60)
    beneficiaries_entry.pack(pady=5)

    # Insurance list display
    insurance_listbox = tk.Listbox(scrollable_frame, height=10, width=70)
    insurance_listbox.pack(pady=10)

    # Refresh listbox content
    def refresh_insurance_list():
        insurance_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for insurance in profile_data.get('insurance', []):
                insurance_details = (
                    f"Type: {insurance['type']} | Policy #: {insurance['policy_number']} | "
                    f"Provider: {insurance['provider_name']} | Beneficiaries: {insurance['beneficiaries'][:50]}"
                )
                insurance_listbox.insert(tk.END, insurance_details)

    # Save insurance details
    def save_insurance():
        insurance_type = insurance_type_entry.get().strip()
        policy_number = policy_number_entry.get().strip()
        provider_name = provider_name_entry.get().strip()
        coverage_details = coverage_details_text.get("1.0", tk.END).strip()
        beneficiaries = beneficiaries_entry.get().strip()

        if insurance_type and policy_number and provider_name and coverage_details:
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'insurance' not in profile_data:
                    profile_data['insurance'] = []
                profile_data['insurance'].append({
                    "type": insurance_type,
                    "policy_number": policy_number,
                    "provider_name": provider_name,
                    "coverage_details": coverage_details,
                    "beneficiaries": beneficiaries
                })
                # Clear the entry fields after saving
                insurance_type_entry.delete(0, tk.END)
                policy_number_entry.delete(0, tk.END)
                provider_name_entry.delete(0, tk.END)
                coverage_details_text.delete("1.0", tk.END)
                beneficiaries_entry.delete(0, tk.END)

                update_status_callback()  # Update the status label for this section
                refresh_insurance_list()  # Refresh the list display
                save_profiles(profiles)  # Save profiles to file
        else:
            messagebox.showwarning("Input Error", "Please fill in all required fields.")

    # Add button to save insurance
    tk.Button(scrollable_frame, text="Save Insurance", command=save_insurance).pack(pady=10)

    # Populate the listbox with existing insurance entries
    refresh_insurance_list()


def open_banking_window(profile_name, update_status_callback):
    banking_window = tk.Toplevel()
    banking_window.title(f"Manage Banking Information for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(banking_window)
    scrollbar = tk.Scrollbar(banking_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Fields for entering banking details
    tk.Label(scrollable_frame, text="Bank Name:").pack(pady=5)
    bank_name_entry = tk.Entry(scrollable_frame, width=60)
    bank_name_entry.pack(pady=5)
    bank_name_entry.focus_set()

    tk.Label(scrollable_frame, text="Account Type (e.g., Checking, Savings):").pack(pady=5)
    account_type_entry = tk.Entry(scrollable_frame, width=60)
    account_type_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Account Number:").pack(pady=5)
    account_number_entry = tk.Entry(scrollable_frame, width=60)
    account_number_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Branch Location:").pack(pady=5)
    branch_location_entry = tk.Entry(scrollable_frame, width=60)
    branch_location_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Additional Notes:").pack(pady=5)
    notes_text = tk.Text(scrollable_frame, height=6, width=70, wrap="word")
    notes_text.pack(pady=5)

    # Banking list display
    banking_listbox = tk.Listbox(scrollable_frame, height=10, width=70)
    banking_listbox.pack(pady=10)

    # Refresh listbox content
    def refresh_banking_list():
        banking_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for bank in profile_data.get('banking', []):
                bank_details = (
                    f"Bank: {bank['bank_name']} | Account Type: {bank['account_type']} | "
                    f"Account #: {bank['account_number']} | Branch: {bank['branch_location']}"
                )
                banking_listbox.insert(tk.END, bank_details)

    # Save banking details
    def save_banking():
        bank_name = bank_name_entry.get().strip()
        account_type = account_type_entry.get().strip()
        account_number = account_number_entry.get().strip()
        branch_location = branch_location_entry.get().strip()
        notes = notes_text.get("1.0", tk.END).strip()

        if bank_name and account_type and account_number and branch_location:
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'banking' not in profile_data:
                    profile_data['banking'] = []
                profile_data['banking'].append({
                    "bank_name": bank_name,
                    "account_type": account_type,
                    "account_number": account_number,
                    "branch_location": branch_location,
                    "notes": notes
                })
                # Clear the entry fields after saving
                bank_name_entry.delete(0, tk.END)
                account_type_entry.delete(0, tk.END)
                account_number_entry.delete(0, tk.END)
                branch_location_entry.delete(0, tk.END)
                notes_text.delete("1.0", tk.END)

                update_status_callback()  # Update the status label for this section
                refresh_banking_list()  # Refresh the list display
                save_profiles(profiles)  # Save profiles to file
        else:
            messagebox.showwarning("Input Error", "Please fill in all required fields.")

    # Add button to save banking details
    tk.Button(scrollable_frame, text="Save Banking Details", command=save_banking).pack(pady=10)

    # Populate the listbox with existing banking entries
    refresh_banking_list()



def open_retirement_window(profile_name, update_status_callback):
    retirement_window = tk.Toplevel()
    retirement_window.title(f"Manage Retirement Information for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(retirement_window)
    scrollbar = tk.Scrollbar(retirement_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Fields for entering retirement details
    tk.Label(scrollable_frame, text="Retirement Plan Name:").pack(pady=5)
    plan_name_entry = tk.Entry(scrollable_frame, width=60)
    plan_name_entry.pack(pady=5)
    plan_name_entry.focus_set()

    tk.Label(scrollable_frame, text="Account Type (e.g., 401(k), IRA):").pack(pady=5)
    account_type_entry = tk.Entry(scrollable_frame, width=60)
    account_type_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Account Number:").pack(pady=5)
    account_number_entry = tk.Entry(scrollable_frame, width=60)
    account_number_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Provider (e.g., Vanguard, Fidelity):").pack(pady=5)
    provider_entry = tk.Entry(scrollable_frame, width=60)
    provider_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Beneficiaries:").pack(pady=5)
    beneficiaries_entry = tk.Entry(scrollable_frame, width=60)
    beneficiaries_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Additional Notes:").pack(pady=5)
    notes_text = tk.Text(scrollable_frame, height=6, width=70, wrap="word")
    notes_text.pack(pady=5)

    # Retirement list display
    retirement_listbox = tk.Listbox(scrollable_frame, height=10, width=70)
    retirement_listbox.pack(pady=10)

    # Refresh listbox content
    def refresh_retirement_list():
        retirement_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for plan in profile_data.get('retirement', []):
                plan_details = (
                    f"Plan: {plan['plan_name']} | Type: {plan['account_type']} | "
                    f"Provider: {plan['provider']} | Beneficiaries: {plan['beneficiaries']}"
                )
                retirement_listbox.insert(tk.END, plan_details)

    # Save retirement details
    def save_retirement():
        plan_name = plan_name_entry.get().strip()
        account_type = account_type_entry.get().strip()
        account_number = account_number_entry.get().strip()
        provider = provider_entry.get().strip()
        beneficiaries = beneficiaries_entry.get().strip()
        notes = notes_text.get("1.0", tk.END).strip()

        if plan_name and account_type and account_number and provider:
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'retirement' not in profile_data:
                    profile_data['retirement'] = []
                profile_data['retirement'].append({
                    "plan_name": plan_name,
                    "account_type": account_type,
                    "account_number": account_number,
                    "provider": provider,
                    "beneficiaries": beneficiaries,
                    "notes": notes
                })
                # Clear the entry fields after saving
                plan_name_entry.delete(0, tk.END)
                account_type_entry.delete(0, tk.END)
                account_number_entry.delete(0, tk.END)
                provider_entry.delete(0, tk.END)
                beneficiaries_entry.delete(0, tk.END)
                notes_text.delete("1.0", tk.END)

                update_status_callback()  # Update the status label for this section
                refresh_retirement_list()  # Refresh the list display
                save_profiles(profiles)  # Save profiles to file
        else:
            messagebox.showwarning("Input Error", "Please fill in all required fields.")

    # Add button to save retirement details
    tk.Button(scrollable_frame, text="Save Retirement Details", command=save_retirement).pack(pady=10)

    # Populate the listbox with existing retirement entries
    refresh_retirement_list()


def open_government_benefits_window(profile_name, update_status_callback):
    benefits_window = tk.Toplevel()
    benefits_window.title(f"Manage Government Benefits for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(benefits_window)
    scrollbar = tk.Scrollbar(benefits_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Fields for entering government benefits details
    tk.Label(scrollable_frame, text="Benefit Type (e.g., Social Security, Medicare):").pack(pady=5)
    benefit_type_entry = tk.Entry(scrollable_frame, width=60)
    benefit_type_entry.pack(pady=5)
    benefit_type_entry.focus_set()

    tk.Label(scrollable_frame, text="Account Number:").pack(pady=5)
    account_number_entry = tk.Entry(scrollable_frame, width=60)
    account_number_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Agency/Provider (e.g., SSA, VA):").pack(pady=5)
    agency_entry = tk.Entry(scrollable_frame, width=60)
    agency_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Start Date (YYYY-MM-DD):").pack(pady=5)
    start_date_entry = tk.Entry(scrollable_frame, width=60)
    start_date_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Monthly Benefit Amount:").pack(pady=5)
    monthly_amount_entry = tk.Entry(scrollable_frame, width=60)
    monthly_amount_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Additional Notes:").pack(pady=5)
    notes_text = tk.Text(scrollable_frame, height=6, width=70, wrap="word")
    notes_text.pack(pady=5)

    # Government benefits list display
    benefits_listbox = tk.Listbox(scrollable_frame, height=10, width=70)
    benefits_listbox.pack(pady=10)

    # Refresh listbox content
    def refresh_benefits_list():
        benefits_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for benefit in profile_data.get('government_benefits', []):
                benefit_details = (
                    f"Type: {benefit['benefit_type']} | Agency: {benefit['agency']} | "
                    f"Start Date: {benefit['start_date']} | Monthly Amount: ${benefit['monthly_amount']}"
                )
                benefits_listbox.insert(tk.END, benefit_details)

    # Save government benefits details
    def save_benefit():
        benefit_type = benefit_type_entry.get().strip()
        account_number = account_number_entry.get().strip()
        agency = agency_entry.get().strip()
        start_date = start_date_entry.get().strip()
        monthly_amount = monthly_amount_entry.get().strip()
        notes = notes_text.get("1.0", tk.END).strip()

        if benefit_type and account_number and agency and start_date and monthly_amount:
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'government_benefits' not in profile_data:
                    profile_data['government_benefits'] = []
                profile_data['government_benefits'].append({
                    "benefit_type": benefit_type,
                    "account_number": account_number,
                    "agency": agency,
                    "start_date": start_date,
                    "monthly_amount": monthly_amount,
                    "notes": notes
                })
                # Clear the entry fields after saving
                benefit_type_entry.delete(0, tk.END)
                account_number_entry.delete(0, tk.END)
                agency_entry.delete(0, tk.END)
                start_date_entry.delete(0, tk.END)
                monthly_amount_entry.delete(0, tk.END)
                notes_text.delete("1.0", tk.END)

                update_status_callback()  # Update the status label for this section
                refresh_benefits_list()  # Refresh the list display
                save_profiles(profiles)  # Save profiles to file
        else:
            messagebox.showwarning("Input Error", "Please fill in all required fields.")

    # Add button to save government benefits details
    tk.Button(scrollable_frame, text="Save Government Benefit", command=save_benefit).pack(pady=10)

    # Populate the listbox with existing government benefits entries
    refresh_benefits_list()


def open_credit_debt_window(profile_name, update_status_callback):
    credit_debt_window = tk.Toplevel()
    credit_debt_window.title(f"Manage Credit and Debt for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(credit_debt_window)
    scrollbar = tk.Scrollbar(credit_debt_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Fields for entering credit and debt details
    tk.Label(scrollable_frame, text="Type (e.g., Credit Card, Loan):").pack(pady=5)
    debt_type_entry = tk.Entry(scrollable_frame, width=60)
    debt_type_entry.pack(pady=5)
    debt_type_entry.focus_set()

    tk.Label(scrollable_frame, text="Account Number:").pack(pady=5)
    account_number_entry = tk.Entry(scrollable_frame, width=60)
    account_number_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Lender Name (e.g., Bank, Credit Union):").pack(pady=5)
    lender_entry = tk.Entry(scrollable_frame, width=60)
    lender_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Outstanding Balance ($):").pack(pady=5)
    balance_entry = tk.Entry(scrollable_frame, width=60)
    balance_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Interest Rate (%):").pack(pady=5)
    interest_rate_entry = tk.Entry(scrollable_frame, width=60)
    interest_rate_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Monthly Payment ($):").pack(pady=5)
    monthly_payment_entry = tk.Entry(scrollable_frame, width=60)
    monthly_payment_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Due Date (YYYY-MM-DD):").pack(pady=5)
    due_date_entry = tk.Entry(scrollable_frame, width=60)
    due_date_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Additional Notes:").pack(pady=5)
    notes_text = tk.Text(scrollable_frame, height=6, width=70, wrap="word")
    notes_text.pack(pady=5)

    # Credit and debt list display
    credit_debt_listbox = tk.Listbox(scrollable_frame, height=10, width=70)
    credit_debt_listbox.pack(pady=10)

    # Refresh listbox content
    def refresh_credit_debt_list():
        credit_debt_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for debt in profile_data.get('credit_debt', []):
                debt_details = (
                    f"Type: {debt['type']} | Lender: {debt['lender']} | "
                    f"Balance: ${debt['balance']} | Due Date: {debt['due_date']}"
                )
                credit_debt_listbox.insert(tk.END, debt_details)

    # Save credit and debt details
    def save_credit_debt():
        debt_type = debt_type_entry.get().strip()
        account_number = account_number_entry.get().strip()
        lender = lender_entry.get().strip()
        balance = balance_entry.get().strip()
        interest_rate = interest_rate_entry.get().strip()
        monthly_payment = monthly_payment_entry.get().strip()
        due_date = due_date_entry.get().strip()
        notes = notes_text.get("1.0", tk.END).strip()

        if debt_type and account_number and lender and balance and due_date:
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'credit_debt' not in profile_data:
                    profile_data['credit_debt'] = []
                profile_data['credit_debt'].append({
                    "type": debt_type,
                    "account_number": account_number,
                    "lender": lender,
                    "balance": balance,
                    "interest_rate": interest_rate,
                    "monthly_payment": monthly_payment,
                    "due_date": due_date,
                    "notes": notes
                })
                # Clear the entry fields after saving
                debt_type_entry.delete(0, tk.END)
                account_number_entry.delete(0, tk.END)
                lender_entry.delete(0, tk.END)
                balance_entry.delete(0, tk.END)
                interest_rate_entry.delete(0, tk.END)
                monthly_payment_entry.delete(0, tk.END)
                due_date_entry.delete(0, tk.END)
                notes_text.delete("1.0", tk.END)

                update_status_callback()  # Update the status label for this section
                refresh_credit_debt_list()  # Refresh the list display
                save_profiles(profiles)  # Save profiles to file
        else:
            messagebox.showwarning("Input Error", "Please fill in all required fields.")

    # Add button to save credit and debt details
    tk.Button(scrollable_frame, text="Save Credit/Debt", command=save_credit_debt).pack(pady=10)

    # Populate the listbox with existing credit and debt entries
    refresh_credit_debt_list()

def open_secured_places_window(profile_name, update_status_callback):
    secured_places_window = tk.Toplevel()
    secured_places_window.title(f"Manage Secured Places for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(secured_places_window)
    scrollbar = tk.Scrollbar(secured_places_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Fields for entering secured place details
    tk.Label(scrollable_frame, text="Name or Type of Secured Place (e.g., Safe, Storage Unit):").pack(pady=5)
    place_type_entry = tk.Entry(scrollable_frame, width=60)
    place_type_entry.pack(pady=5)
    place_type_entry.focus_set()

    tk.Label(scrollable_frame, text="Location or Address:").pack(pady=5)
    location_entry = tk.Entry(scrollable_frame, width=60)
    location_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Access Details (e.g., Key, Code, Combination):").pack(pady=5)
    access_details_entry = tk.Entry(scrollable_frame, width=60)
    access_details_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Contents or Items Stored:").pack(pady=5)
    contents_text = tk.Text(scrollable_frame, height=6, width=70, wrap="word")
    contents_text.pack(pady=5)

    tk.Label(scrollable_frame, text="Additional Notes:").pack(pady=5)
    notes_text = tk.Text(scrollable_frame, height=6, width=70, wrap="word")
    notes_text.pack(pady=5)

    # Secured places list display
    secured_places_listbox = tk.Listbox(scrollable_frame, height=10, width=70)
    secured_places_listbox.pack(pady=10)

    # Refresh listbox content
    def refresh_secured_places_list():
        secured_places_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for place in profile_data.get('secured_places', []):
                place_details = (
                    f"Type: {place['type']} | Location: {place['location']} | Access: {place['access_details']}"
                )
                secured_places_listbox.insert(tk.END, place_details)

    # Save secured place details
    def save_secured_place():
        place_type = place_type_entry.get().strip()
        location = location_entry.get().strip()
        access_details = access_details_entry.get().strip()
        contents = contents_text.get("1.0", tk.END).strip()
        notes = notes_text.get("1.0", tk.END).strip()

        if place_type and location and access_details:
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'secured_places' not in profile_data:
                    profile_data['secured_places'] = []
                profile_data['secured_places'].append({
                    "type": place_type,
                    "location": location,
                    "access_details": access_details,
                    "contents": contents,
                    "notes": notes
                })
                # Clear the entry fields after saving
                place_type_entry.delete(0, tk.END)
                location_entry.delete(0, tk.END)
                access_details_entry.delete(0, tk.END)
                contents_text.delete("1.0", tk.END)
                notes_text.delete("1.0", tk.END)

                update_status_callback()  # Update the status label for this section
                refresh_secured_places_list()  # Refresh the list display
                save_profiles(profiles)  # Save profiles to file
        else:
            messagebox.showwarning("Input Error", "Please fill in all required fields.")

    # Add button to save secured place details
    tk.Button(scrollable_frame, text="Save Secured Place", command=save_secured_place).pack(pady=10)

    # Populate the listbox with existing secured place entries
    refresh_secured_places_list()


def open_taxes_window(profile_name, update_status_callback):
    taxes_window = tk.Toplevel()
    taxes_window.title(f"Manage Taxes for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(taxes_window)
    scrollbar = tk.Scrollbar(taxes_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Fields for entering tax information
    tk.Label(scrollable_frame, text="Taxpayer Name or Entity:").pack(pady=5)
    taxpayer_entry = tk.Entry(scrollable_frame, width=60)
    taxpayer_entry.pack(pady=5)
    taxpayer_entry.focus_set()

    tk.Label(scrollable_frame, text="Tax ID (e.g., SSN, EIN, or ITIN):").pack(pady=5)
    tax_id_entry = tk.Entry(scrollable_frame, width=60)
    tax_id_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Tax Filing Year:").pack(pady=5)
    filing_year_entry = tk.Entry(scrollable_frame, width=60)
    filing_year_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Documents or References:").pack(pady=5)
    documents_text = tk.Text(scrollable_frame, height=6, width=70, wrap="word")
    documents_text.pack(pady=5)

    tk.Label(scrollable_frame, text="Additional Notes:").pack(pady=5)
    notes_text = tk.Text(scrollable_frame, height=6, width=70, wrap="word")
    notes_text.pack(pady=5)

    # Tax records list display
    taxes_listbox = tk.Listbox(scrollable_frame, height=10, width=70)
    taxes_listbox.pack(pady=10)

    # Refresh listbox content
    def refresh_taxes_list():
        taxes_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for tax_record in profile_data.get('taxes', []):
                tax_details = (
                    f"Name: {tax_record['taxpayer']} | Tax ID: {tax_record['tax_id']} | Year: {tax_record['filing_year']}"
                )
                taxes_listbox.insert(tk.END, tax_details)

    # Save tax record
    def save_tax_record():
        taxpayer = taxpayer_entry.get().strip()
        tax_id = tax_id_entry.get().strip()
        filing_year = filing_year_entry.get().strip()
        documents = documents_text.get("1.0", tk.END).strip()
        notes = notes_text.get("1.0", tk.END).strip()

        if taxpayer and tax_id and filing_year:
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'taxes' not in profile_data:
                    profile_data['taxes'] = []
                profile_data['taxes'].append({
                    "taxpayer": taxpayer,
                    "tax_id": tax_id,
                    "filing_year": filing_year,
                    "documents": documents,
                    "notes": notes
                })
                # Clear the entry fields after saving
                taxpayer_entry.delete(0, tk.END)
                tax_id_entry.delete(0, tk.END)
                filing_year_entry.delete(0, tk.END)
                documents_text.delete("1.0", tk.END)
                notes_text.delete("1.0", tk.END)

                update_status_callback()  # Update the status label for this section
                refresh_taxes_list()  # Refresh the list display
                save_profiles(profiles)  # Save profiles to file
        else:
            messagebox.showwarning("Input Error", "Please fill in all required fields.")

    # Add button to save tax record
    tk.Button(scrollable_frame, text="Save Tax Record", command=save_tax_record).pack(pady=10)

    # Populate the listbox with existing tax records
    refresh_taxes_list()

def open_real_estate_window(profile_name, update_status_callback):
    real_estate_window = tk.Toplevel()
    real_estate_window.title(f"Manage Real Estate for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(real_estate_window)
    scrollbar = tk.Scrollbar(real_estate_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Fields for entering real estate information
    tk.Label(scrollable_frame, text="Property Address:").pack(pady=5)
    address_entry = tk.Entry(scrollable_frame, width=60)
    address_entry.pack(pady=5)
    address_entry.focus_set()

    tk.Label(scrollable_frame, text="Property Type (e.g., Residential, Commercial):").pack(pady=5)
    property_type_entry = tk.Entry(scrollable_frame, width=60)
    property_type_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Ownership Details:").pack(pady=5)
    ownership_entry = tk.Entry(scrollable_frame, width=60)
    ownership_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Mortgage Details:").pack(pady=5)
    mortgage_text = tk.Text(scrollable_frame, height=6, width=70, wrap="word")
    mortgage_text.pack(pady=5)

    tk.Label(scrollable_frame, text="Additional Notes:").pack(pady=5)
    notes_text = tk.Text(scrollable_frame, height=6, width=70, wrap="word")
    notes_text.pack(pady=5)

    # Listbox to display saved properties
    properties_listbox = tk.Listbox(scrollable_frame, height=10, width=70)
    properties_listbox.pack(pady=10)

    # Refresh the listbox content
    def refresh_properties_list():
        properties_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for property_record in profile_data.get('real_estate', []):
                property_details = (
                    f"Address: {property_record['address']} | Type: {property_record['property_type']}"
                )
                properties_listbox.insert(tk.END, property_details)

    # Save real estate record
    def save_property_record():
        address = address_entry.get().strip()
        property_type = property_type_entry.get().strip()
        ownership = ownership_entry.get().strip()
        mortgage = mortgage_text.get("1.0", tk.END).strip()
        notes = notes_text.get("1.0", tk.END).strip()

        if address and property_type and ownership:
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'real_estate' not in profile_data:
                    profile_data['real_estate'] = []
                profile_data['real_estate'].append({
                    "address": address,
                    "property_type": property_type,
                    "ownership": ownership,
                    "mortgage": mortgage,
                    "notes": notes
                })
                # Clear the entry fields after saving
                address_entry.delete(0, tk.END)
                property_type_entry.delete(0, tk.END)
                ownership_entry.delete(0, tk.END)
                mortgage_text.delete("1.0", tk.END)
                notes_text.delete("1.0", tk.END)

                update_status_callback()  # Update the status label for this section
                refresh_properties_list()  # Refresh the list display
                save_profiles(profiles)  # Save profiles to file
        else:
            messagebox.showwarning("Input Error", "Please fill in all required fields.")

    # Add button to save property record
    tk.Button(scrollable_frame, text="Save Property Record", command=save_property_record).pack(pady=10)

    # Populate the listbox with existing property records
    refresh_properties_list()

def open_personal_property_window(profile_name, update_status_callback):
    personal_property_window = tk.Toplevel()
    personal_property_window.title(f"Manage Personal Property for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(personal_property_window)
    scrollbar = tk.Scrollbar(personal_property_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Fields for entering personal property information
    tk.Label(scrollable_frame, text="Item Name:").pack(pady=5)
    item_name_entry = tk.Entry(scrollable_frame, width=60)
    item_name_entry.pack(pady=5)
    item_name_entry.focus_set()

    tk.Label(scrollable_frame, text="Item Description:").pack(pady=5)
    item_description_text = tk.Text(scrollable_frame, height=4, width=70, wrap="word")
    item_description_text.pack(pady=5)

    tk.Label(scrollable_frame, text="Estimated Value:").pack(pady=5)
    item_value_entry = tk.Entry(scrollable_frame, width=60)
    item_value_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Location:").pack(pady=5)
    item_location_entry = tk.Entry(scrollable_frame, width=60)
    item_location_entry.pack(pady=5)

    # Listbox to display saved items
    items_listbox = tk.Listbox(scrollable_frame, height=10, width=70)
    items_listbox.pack(pady=10)

    # Refresh the listbox content
    def refresh_items_list():
        items_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for item in profile_data.get('personal_property', []):
                item_details = f"Name: {item['name']} | Value: ${item['value']}"
                items_listbox.insert(tk.END, item_details)

    # Save personal property record
    def save_item_record():
        name = item_name_entry.get().strip()
        description = item_description_text.get("1.0", tk.END).strip()
        value = item_value_entry.get().strip()
        location = item_location_entry.get().strip()

        if name and value and location:
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'personal_property' not in profile_data:
                    profile_data['personal_property'] = []
                profile_data['personal_property'].append({
                    "name": name,
                    "description": description,
                    "value": value,
                    "location": location
                })
                # Clear the entry fields after saving
                item_name_entry.delete(0, tk.END)
                item_description_text.delete("1.0", tk.END)
                item_value_entry.delete(0, tk.END)
                item_location_entry.delete(0, tk.END)

                update_status_callback()  # Update the status label for this section
                refresh_items_list()  # Refresh the list display
                save_profiles(profiles)  # Save profiles to file
        else:
            messagebox.showwarning("Input Error", "Please fill in all required fields (Name, Value, Location).")

    # Add button to save item record
    tk.Button(scrollable_frame, text="Save Item Record", command=save_item_record).pack(pady=10)

    # Populate the listbox with existing personal property records
    refresh_items_list()

def open_other_information_window(profile_name, update_status_callback):
    other_information_window = tk.Toplevel()
    other_information_window.title(f"Manage Other Information for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(other_information_window)
    scrollbar = tk.Scrollbar(other_information_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Fields for entering other information
    tk.Label(scrollable_frame, text="Title (e.g., Special Wishes, Notes, etc.):").pack(pady=5)
    title_entry = tk.Entry(scrollable_frame, width=60)
    title_entry.pack(pady=5)
    title_entry.focus_set()

    tk.Label(scrollable_frame, text="Description/Details:").pack(pady=5)
    details_text = tk.Text(scrollable_frame, height=6, width=70, wrap="word")
    details_text.pack(pady=5)

    # Listbox to display saved other information entries
    other_info_listbox = tk.Listbox(scrollable_frame, height=10, width=70)
    other_info_listbox.pack(pady=10)

    # Refresh the listbox content
    def refresh_other_info_list():
        other_info_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for info in profile_data.get('other_information', []):
                info_details = f"Title: {info['title']} | {info['description'][:50]}..."  # Show truncated description
                other_info_listbox.insert(tk.END, info_details)

    # Save other information record
    def save_other_info():
        title = title_entry.get().strip()
        description = details_text.get("1.0", tk.END).strip()

        if title and description:
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'other_information' not in profile_data:
                    profile_data['other_information'] = []
                profile_data['other_information'].append({
                    "title": title,
                    "description": description
                })
                # Clear the entry fields after saving
                title_entry.delete(0, tk.END)
                details_text.delete("1.0", tk.END)

                update_status_callback()  # Update the status label for this section
                refresh_other_info_list()  # Refresh the list display
                save_profiles(profiles)  # Save profiles to file
        else:
            messagebox.showwarning("Input Error", "Please fill in both the Title and Description.")

    # Add button to save other information
    tk.Button(scrollable_frame, text="Save Information", command=save_other_info).pack(pady=10)

    # Populate the listbox with existing other information records
    refresh_other_info_list()



import tkinter as tk

def open_profile_window(profile_name):
    profile_window = tk.Toplevel()
    profile_window.title(f"Profile: {profile_name}")
    profile_window.state('zoomed')

    # Create a canvas and scrollbar
    canvas = tk.Canvas(profile_window)
    scrollbar = tk.Scrollbar(profile_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    # Configure the canvas to scroll the frame
    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )
    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack canvas and scrollbar
    canvas.pack(side="left", fill="both", expand=True)
    scrollbar.pack(side="right", fill="y")

    # Add a title to the scrollable frame
    tk.Label(scrollable_frame, text=f"Manage {profile_name}'s Information", font=("Arial", 20)).grid(row=0, column=0, columnspan=2, pady=10)

    profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        
    if profile_data:
        # Sections with their commands
        sections = [
            ("Manage Next Steps", "next_steps", lambda: open_next_steps_window(profile_name, update_status_callback)),
            ("Letter to Loved Ones", "recipients", lambda: open_letter_to_loved_ones(profile_name, update_status_callback)),
            ("Manage Contacts", "contacts", lambda: open_contacts_window(profile_name, update_status_callback)),
            ("Manage Your Biography", "biographies", lambda: open_biography_window(profile_name, update_status_callback)),
            ("Manage Parents Biographies", "biographies2", lambda: open_biography_window2(profile_name, update_status_callback)),
            ("Manage Siblings Biographies", "biographies3", lambda: open_biography_window2(profile_name, update_status_callback)),
            ("Manage Children", "children", lambda: open_children_window(profile_name, update_status_callback)),
            ("Manage People Who Dependend On You", "dependents", lambda: open_dependents_window(profile_name, update_status_callback)),
            ("Manage Pets", "pet", lambda: open_pet_livestock_window(profile_name, update_status_callback)),
            ("Manage Employment", "employment", lambda: open_employment_window(profile_name, update_status_callback)),
            ("Manage Business Interests", "business_interests", lambda: open_business_interests_window(profile_name, update_status_callback)),
            ("Memberships Status", "memberships", lambda: open_memberships_window(profile_name, update_status_callback)),
            ("Manage Service Providers", "service_providers", lambda: open_service_providers_window(profile_name, update_status_callback)),
            ("Manage Vehicles", "vehicles", lambda: open_vehicles_window(profile_name, update_status_callback)),
            
            # Added status sections
            ("Employment", "employment", lambda: open_employment_window(profile_name, update_status_callback)),
            ("Business Interests", "business_interests", lambda: open_business_interests_window(profile_name, update_status_callback)),
            ("Service Providers", "service_providers", lambda: open_service_providers_window(profile_name, update_status_callback)),
            ("Health Care Directives", "health_care_directives", lambda: open_health_care_directives_window(profile_name, update_status_callback)),
            ("Power of Attorney", "power_of_attorney", lambda: open_power_of_attorney_window(profile_name, update_status_callback)),
            ("Organ Donation", "organ_donation", lambda: open_organ_donation_window(profile_name, update_status_callback)),
            ("Burial & Cremation", "burial_cremation", lambda: open_burial_cremation_window(profile_name, update_status_callback)),
            ("Funeral Services", "funeral_services", lambda: open_funeral_services_window(profile_name, update_status_callback)),
            ("Obituary", "obituary", lambda: open_obituary_window(profile_name, update_status_callback)),
            ("Wills and Trusts", "wills_and_trusts", lambda: open_will_and_trust_window(profile_name, update_status_callback)),
            ("Insurance", "insurance", lambda: open_insurance_window(profile_name, update_status_callback)),
            ("Banking", "banking", lambda: open_banking_window(profile_name, update_status_callback)),
            ("Retirement", "retirement", lambda: open_retirement_window(profile_name, update_status_callback)),
            ("Government Benefits", "government_benefits", lambda: open_government_benefits_window(profile_name, update_status_callback)),
            ("Credit & Debt", "credit_debt", lambda: open_credit_debt_window(profile_name, update_status_callback)),
            ("Secured Places", "secured_places", lambda: open_secured_places_window(profile_name, update_status_callback)),
            ("Taxes", "taxes", lambda: open_taxes_window(profile_name, update_status_callback)),
            ("Real Estate", "real_estate", lambda: open_real_estate_window(profile_name, update_status_callback)),
            ("Personal Property", "personal_property", lambda: open_personal_property_window(profile_name, update_status_callback)),
            ("Other Information", "other_information", lambda: open_other_information_window(profile_name, update_status_callback)),
        ]

        # Dictionary to store status labels
        status_labels = {}

        def update_status_callback():
            """Update the status of each section dynamically."""
            print("Updating status...")  # Debugging line
            for _, key, _ in sections:
                section_status = "Complete" if profile_data.get(key, []) else "Incomplete"
                print(f"Section {key} status: {section_status}")  # Debugging line
                status_labels[key].config(text=section_status)


        # Create buttons and labels
        for i, (button_text, key, command) in enumerate(sections, start=1):
            section_status = "Complete" if profile_data.get(key, []) else "Incomplete"
            tk.Button(scrollable_frame, text=button_text, command=command).grid(row=i, column=0, pady=5, padx=10)
            status_label = tk.Label(scrollable_frame, text=section_status)
            status_label.grid(row=i, column=1)
            status_labels[key] = status_label

    profile_window.mainloop()


from tkinter import filedialog

def generate_profile_pdf(profile_name):
    """Generate a PDF for the highlighted profile."""
    profile_data = next((p for p in profiles if p['name'] == profile_name), None)
    if not profile_data:
        messagebox.showwarning("Error", f"No data found for profile '{profile_name}'")
        return

    # Prompt the user to select a folder
    folder_path = filedialog.askdirectory(title="Select Folder to Save PDF")
    if not folder_path:
        return  # User canceled folder selection

    # Construct the full file path
    pdf_filename = f"{profile_name}_profile.pdf"
    file_path = f"{folder_path}/{pdf_filename}"

    # Initialize PDF
    c = canvas.Canvas(file_path, pagesize=letter)
    width, height = letter

    # Title
    c.setFont("Helvetica", 16)
    c.drawString(100, height - 40, f"Profile Summary for {profile_name}")

    # Starting Y position for content
    y_position = height - 80

    # Function to recursively process and write nested data
    def write_data(data, indent=0):
        nonlocal y_position
        if isinstance(data, dict):
            for key, value in data.items():
                c.setFont("Helvetica", 10)
                c.drawString(120 + indent, y_position, f"{key.capitalize()}:")
                y_position -= 15
                write_data(value, indent + 20)
        elif isinstance(data, list):
            for item in data:
                write_data(item, indent)
        else:
            c.setFont("Helvetica", 10)
            c.drawString(120 + indent, y_position, f"- {data}")
            y_position -= 15

    # Add profile sections
    for section_title, section_content in profile_data.items():
        if section_title != 'name':  # Skip the profile name in sections
            c.setFont("Helvetica-Bold", 12)
            c.drawString(100, y_position, f"{section_title.capitalize()}:")
            y_position -= 20
            if section_content:
                write_data(section_content)
            else:
                c.setFont("Helvetica", 10)
                c.drawString(120, y_position, "No data available.")
                y_position -= 15

            # Check for page overflow
            if y_position < 40:
                c.showPage()
                y_position = height - 40

    # Save PDF
    c.save()
    messagebox.showinfo("PDF Generated", f"PDF for '{profile_name}' has been saved to '{file_path}'.")




def open_children_window(profile_name, update_status_callback):
    children_window = tk.Toplevel()
    children_window.title(f"Manage Children for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(children_window)
    scrollbar = tk.Scrollbar(children_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Fields for entering child details
    tk.Label(scrollable_frame, text="Child's Full Name:").pack(pady=5)
    name_entry = tk.Entry(scrollable_frame)
    name_entry.pack(pady=5)
    name_entry.focus_set()

    tk.Label(scrollable_frame, text="Date of Birth (YYYY-MM-DD):").pack(pady=5)
    dob_entry = tk.Entry(scrollable_frame)
    dob_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Birthplace:").pack(pady=5)
    birthplace_entry = tk.Entry(scrollable_frame)
    birthplace_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Relationship Type (e.g., Biological, Step, Adopted):").pack(pady=5)
    relationship_entry = tk.Entry(scrollable_frame)
    relationship_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Additional Notes:").pack(pady=5)
    notes_entry = tk.Entry(scrollable_frame)
    notes_entry.pack(pady=5)

    # Children list display
    children_listbox = tk.Listbox(scrollable_frame, height=10, width=70)
    children_listbox.pack(pady=10)

    # Refresh listbox content
    def refresh_children_list():
        children_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for child in profile_data.get('children', []):
                child_details = (
                    f"{child['name']} | {child['dob']} | {child['birthplace']} | "
                    f"{child['relationship']} | {child['notes']}"
                )
                children_listbox.insert(tk.END, child_details)

    # Save child details
    def save_child():
        name = name_entry.get()
        dob = dob_entry.get()
        birthplace = birthplace_entry.get()
        relationship = relationship_entry.get()
        notes = notes_entry.get()

        if name and dob and birthplace and relationship:
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'children' not in profile_data:
                    profile_data['children'] = []
                profile_data['children'].append({
                    "name": name,
                    "dob": dob,
                    "birthplace": birthplace,
                    "relationship": relationship,
                    "notes": notes
                })
                # Clear the entry fields after saving
                name_entry.delete(0, tk.END)
                dob_entry.delete(0, tk.END)
                birthplace_entry.delete(0, tk.END)
                relationship_entry.delete(0, tk.END)
                notes_entry.delete(0, tk.END)

                update_status_callback()  # Update the status label for this section
                refresh_children_list()  # Refresh the list display
                save_profiles(profiles)  # Save profiles to file
        else:
            messagebox.showwarning("Input Error", "Please fill all required fields except Notes (optional).")

    # Add button to save child
    tk.Button(scrollable_frame, text="Save Child", command=save_child).pack(pady=10)

    # Populate the listbox with existing children
    refresh_children_list()


def open_letter_to_loved_ones(profile_name, update_status_callback):
    letter_window = tk.Toplevel()
    letter_window.title(f"Letter to Loved Ones for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(letter_window)
    scrollbar = tk.Scrollbar(letter_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Fields for entering recipient details
    tk.Label(scrollable_frame, text="Recipient's Name:").pack(pady=5)
    name_entry = tk.Entry(scrollable_frame)
    name_entry.pack(pady=5)
    name_entry.focus_set()

    tk.Label(scrollable_frame, text="Recipient's Address:").pack(pady=5)
    address_entry = tk.Entry(scrollable_frame)
    address_entry.pack(pady=5)

    # Recipients list display
    recipients_listbox = tk.Listbox(scrollable_frame, height=10, width=70)
    recipients_listbox.pack(pady=10)

    # Refresh listbox content
    def refresh_recipients_list():
        recipients_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for recipient in profile_data.get('recipients', []):
                recipient_details = f"{recipient['name']} | {recipient['address']}"
                recipients_listbox.insert(tk.END, recipient_details)

    # Save recipient details
    def save_recipient():
        name = name_entry.get()
        address = address_entry.get()

        if name and address:
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'recipients' not in profile_data:
                    profile_data['recipients'] = []
                profile_data['recipients'].append({"name": name, "address": address})
                # Clear the entry fields after saving
                name_entry.delete(0, tk.END)
                address_entry.delete(0, tk.END)

                update_status_callback()  # Update the status label for this section
                refresh_recipients_list()  # Refresh the list display
                save_profiles(profiles)  # Save profiles to file
        else:
            messagebox.showwarning("Input Error", "Please fill out both fields.")

    # Add button to save recipient
    tk.Button(scrollable_frame, text="Add Recipient", command=save_recipient).pack(pady=10)

    # Button to proceed to letter writing
    def open_letter_writing_window():
        # Close the current window
        letter_window.destroy()

        # Open the letter writing window
        letter_writing_window = tk.Toplevel()
        letter_writing_window.title(f"Write Letter for {profile_name}")

        tk.Label(letter_writing_window, text="Write Your Letter Below:").pack(pady=10)

        # Textbox for writing the letter
        letter_textbox = tk.Text(letter_writing_window, height=20, width=70)
        letter_textbox.pack(pady=10)

        # Populate the letter content if it exists
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data and 'letter_content' in profile_data:
            letter_textbox.insert("1.0", profile_data['letter_content'])

        # Save the letter content
        def save_letter():
            letter_content = letter_textbox.get("1.0", tk.END).strip()
            if profile_data:
                profile_data['letter_content'] = letter_content
                save_profiles(profiles)  # Save profiles to file
                update_status_callback()  # Update the status label for this section
                messagebox.showinfo("Success", "Letter content saved successfully!")
                letter_writing_window.destroy()

        tk.Button(letter_writing_window, text="Save Letter", command=save_letter).pack(pady=10)

    tk.Button(scrollable_frame, text="Write Letter to Loved Ones", command=open_letter_writing_window).pack(pady=10)

    # Populate the listbox with existing recipients
    refresh_recipients_list()


def open_dependents_window(profile_name, update_status_callback):
    dependents_window = tk.Toplevel()
    dependents_window.title(f"Manage Dependents for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(dependents_window)
    scrollbar = tk.Scrollbar(dependents_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Fields for entering dependent details
    tk.Label(scrollable_frame, text="Dependent's Full Name:").pack(pady=5)
    name_entry = tk.Entry(scrollable_frame)
    name_entry.pack(pady=5)
    name_entry.focus_set()

    tk.Label(scrollable_frame, text="Relationship (e.g., Parent, Sibling):").pack(pady=5)
    relationship_entry = tk.Entry(scrollable_frame)
    relationship_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Age:").pack(pady=5)
    age_entry = tk.Entry(scrollable_frame)
    age_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Reason for Dependence:").pack(pady=5)
    reason_entry = tk.Entry(scrollable_frame)
    reason_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Type of Support Provided (e.g., Financial, Emotional):").pack(pady=5)
    support_entry = tk.Entry(scrollable_frame)
    support_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Additional Notes:").pack(pady=5)
    notes_entry = tk.Entry(scrollable_frame)
    notes_entry.pack(pady=5)

    # Care Providers Contact Information Section
    tk.Label(scrollable_frame, text="Care Provider's Full Name:").pack(pady=5)
    care_provider_name_entry = tk.Entry(scrollable_frame)
    care_provider_name_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Relationship to Dependent:").pack(pady=5)
    care_provider_relationship_entry = tk.Entry(scrollable_frame)
    care_provider_relationship_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Phone Number:").pack(pady=5)
    care_provider_phone_entry = tk.Entry(scrollable_frame)
    care_provider_phone_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Additional Notes:").pack(pady=5)
    care_provider_notes_entry = tk.Entry(scrollable_frame)
    care_provider_notes_entry.pack(pady=5)

    # Dependents list display
    dependents_listbox = tk.Listbox(scrollable_frame, height=10, width=90)
    dependents_listbox.pack(pady=10)

    # Refresh listbox content
    def refresh_dependents_list():
        dependents_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for dependent in profile_data.get('dependents', []):
                dependent_details = (
                    f"{dependent['name']} | {dependent['relationship']} | Age: {dependent['age']} | "
                    f"Reason: {dependent['reason']} | Support: {dependent['support']} | Notes: {dependent['notes']}"
                )
                care_provider_details = ""
                if 'care_provider' in dependent:
                    care_provider = dependent['care_provider']
                    care_provider_details = (
                        f" | Care Provider: {care_provider['name']} ({care_provider['relationship']}), "
                        f"Phone: {care_provider['phone']} | Notes: {care_provider['notes']}"
                    )
                dependents_listbox.insert(tk.END, dependent_details + care_provider_details)

    # Save dependent details
    def save_dependent():
        name = name_entry.get()
        relationship = relationship_entry.get()
        age = age_entry.get()
        reason = reason_entry.get()
        support = support_entry.get()
        notes = notes_entry.get()

        care_provider_name = care_provider_name_entry.get()
        care_provider_relationship = care_provider_relationship_entry.get()
        care_provider_phone = care_provider_phone_entry.get()
        care_provider_notes = care_provider_notes_entry.get()

        if name and relationship and age and reason and support:
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'dependents' not in profile_data:
                    profile_data['dependents'] = []
                dependent_data = {
                    "name": name,
                    "relationship": relationship,
                    "age": age,
                    "reason": reason,
                    "support": support,
                    "notes": notes
                }

                if care_provider_name:
                    dependent_data["care_provider"] = {
                        "name": care_provider_name,
                        "relationship": care_provider_relationship,
                        "phone": care_provider_phone,
                        "notes": care_provider_notes
                    }

                profile_data['dependents'].append(dependent_data)

                # Clear the entry fields after saving
                name_entry.delete(0, tk.END)
                relationship_entry.delete(0, tk.END)
                age_entry.delete(0, tk.END)
                reason_entry.delete(0, tk.END)
                support_entry.delete(0, tk.END)
                notes_entry.delete(0, tk.END)

                care_provider_name_entry.delete(0, tk.END)
                care_provider_relationship_entry.delete(0, tk.END)
                care_provider_phone_entry.delete(0, tk.END)
                care_provider_notes_entry.delete(0, tk.END)

                update_status_callback()  # Update the status label for this section
                refresh_dependents_list()  # Refresh the list display
                save_profiles(profiles)  # Save profiles to file
        else:
            messagebox.showwarning("Input Error", "Please fill all required fields except Notes (optional).")

    # Add button to save dependent
    tk.Button(scrollable_frame, text="Save Dependent", command=save_dependent).pack(pady=10)

    # Populate the listbox with existing dependents
    refresh_dependents_list()




def open_employment_window(profile_name, update_status_callback):
    employment_window = tk.Toplevel()
    employment_window.title(f"Manage Employment for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(employment_window)
    scrollbar = tk.Scrollbar(employment_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Fields for entering employment details
    tk.Label(scrollable_frame, text="Employer Name:").pack(pady=5)
    employer_entry = tk.Entry(scrollable_frame)
    employer_entry.pack(pady=5)
    employer_entry.focus_set()

    tk.Label(scrollable_frame, text="Position/Title:").pack(pady=5)
    position_entry = tk.Entry(scrollable_frame)
    position_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Start Date (YYYY-MM-DD):").pack(pady=5)
    start_date_entry = tk.Entry(scrollable_frame)
    start_date_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="End Date (YYYY-MM-DD) or 'Present':").pack(pady=5)
    end_date_entry = tk.Entry(scrollable_frame)
    end_date_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Job Location:").pack(pady=5)
    location_entry = tk.Entry(scrollable_frame)
    location_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Additional Notes:").pack(pady=5)
    notes_entry = tk.Entry(scrollable_frame)
    notes_entry.pack(pady=5)

    # Employment list display
    employment_listbox = tk.Listbox(scrollable_frame, height=10, width=70)
    employment_listbox.pack(pady=10)

    # Refresh listbox content
    def refresh_employment_list():
        employment_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for job in profile_data.get('employment', []):
                job_details = (
                    f"{job['employer']} | {job['position']} | {job['start_date']} - {job['end_date']} | "
                    f"Location: {job['location']} | Notes: {job['notes']}"
                )
                employment_listbox.insert(tk.END, job_details)

    # Save employment details
    def save_employment():
        employer = employer_entry.get()
        position = position_entry.get()
        start_date = start_date_entry.get()
        end_date = end_date_entry.get()
        location = location_entry.get()
        notes = notes_entry.get()

        if employer and position and start_date and end_date and location:
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'employment' not in profile_data:
                    profile_data['employment'] = []
                profile_data['employment'].append({
                    "employer": employer,
                    "position": position,
                    "start_date": start_date,
                    "end_date": end_date,
                    "location": location,
                    "notes": notes
                })
                # Clear the entry fields after saving
                employer_entry.delete(0, tk.END)
                position_entry.delete(0, tk.END)
                start_date_entry.delete(0, tk.END)
                end_date_entry.delete(0, tk.END)
                location_entry.delete(0, tk.END)
                notes_entry.delete(0, tk.END)

                update_status_callback()  # Update the status label for this section
                refresh_employment_list()  # Refresh the list display
                save_profiles(profiles)  # Save profiles to file
        else:
            messagebox.showwarning("Input Error", "Please fill all required fields except Notes (optional).")

    # Add button to save employment
    tk.Button(scrollable_frame, text="Save Employment", command=save_employment).pack(pady=10)

    # Populate the listbox with existing employment records
    refresh_employment_list()


def open_memberships_window(profile_name, update_status_callback):
    memberships_window = tk.Toplevel()
    memberships_window.title(f"Manage Memberships for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(memberships_window)
    scrollbar = tk.Scrollbar(memberships_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Fields for entering membership details
    tk.Label(scrollable_frame, text="Membership Name:").pack(pady=5)
    membership_name_entry = tk.Entry(scrollable_frame)
    membership_name_entry.pack(pady=5)
    membership_name_entry.focus_set()

    tk.Label(scrollable_frame, text="Organization Name:").pack(pady=5)
    organization_entry = tk.Entry(scrollable_frame)
    organization_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Membership Start Date (YYYY-MM-DD):").pack(pady=5)
    start_date_entry = tk.Entry(scrollable_frame)
    start_date_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Membership End Date (YYYY-MM-DD) (Optional):").pack(pady=5)
    end_date_entry = tk.Entry(scrollable_frame)
    end_date_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Membership Role or Position:").pack(pady=5)
    role_entry = tk.Entry(scrollable_frame)
    role_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Additional Notes:").pack(pady=5)
    notes_entry = tk.Entry(scrollable_frame)
    notes_entry.pack(pady=5)

    # Membership list display
    memberships_listbox = tk.Listbox(scrollable_frame, height=10, width=70)
    memberships_listbox.pack(pady=10)

    # Refresh listbox content
    def refresh_memberships_list():
        memberships_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for membership in profile_data.get('memberships', []):
                membership_details = (
                    f"{membership['name']} | {membership['organization']} | Start: {membership['start_date']} | "
                    f"End: {membership['end_date']} | Role: {membership['role']} | Notes: {membership['notes']}"
                )
                memberships_listbox.insert(tk.END, membership_details)

    # Save membership details
    def save_membership():
        name = membership_name_entry.get()
        organization = organization_entry.get()
        start_date = start_date_entry.get()
        end_date = end_date_entry.get()
        role = role_entry.get()
        notes = notes_entry.get()

        if name and organization and start_date and role:
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'memberships' not in profile_data:
                    profile_data['memberships'] = []
                profile_data['memberships'].append({
                    "name": name,
                    "organization": organization,
                    "start_date": start_date,
                    "end_date": end_date,
                    "role": role,
                    "notes": notes
                })
                # Clear the entry fields after saving
                membership_name_entry.delete(0, tk.END)
                organization_entry.delete(0, tk.END)
                start_date_entry.delete(0, tk.END)
                end_date_entry.delete(0, tk.END)
                role_entry.delete(0, tk.END)
                notes_entry.delete(0, tk.END)

                update_status_callback()  # Update the status label for this section
                refresh_memberships_list()  # Refresh the list display
                save_profiles(profiles)  # Save profiles to file
        else:
            messagebox.showwarning("Input Error", "Please fill all required fields except Notes and End Date (optional).")

    # Add button to save membership
    tk.Button(scrollable_frame, text="Save Membership", command=save_membership).pack(pady=10)

    # Populate the listbox with existing memberships
    refresh_memberships_list()

def open_service_providers_window(profile_name, update_status_callback):
    service_providers_window = tk.Toplevel()
    service_providers_window.title(f"Manage Service Providers for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(service_providers_window)
    scrollbar = tk.Scrollbar(service_providers_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Fields for entering service provider details
    tk.Label(scrollable_frame, text="Service Provider Name:").pack(pady=5)
    provider_name_entry = tk.Entry(scrollable_frame)
    provider_name_entry.pack(pady=5)
    provider_name_entry.focus_set()

    tk.Label(scrollable_frame, text="Service Type (e.g., Electrician, Plumber, Lawyer):").pack(pady=5)
    service_type_entry = tk.Entry(scrollable_frame)
    service_type_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Contact Number:").pack(pady=5)
    contact_number_entry = tk.Entry(scrollable_frame)
    contact_number_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Email Address (Optional):").pack(pady=5)
    email_entry = tk.Entry(scrollable_frame)
    email_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Address (Optional):").pack(pady=5)
    address_entry = tk.Entry(scrollable_frame)
    address_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Additional Notes:").pack(pady=5)
    notes_entry = tk.Entry(scrollable_frame)
    notes_entry.pack(pady=5)

    # Service provider list display
    service_providers_listbox = tk.Listbox(scrollable_frame, height=10, width=70)
    service_providers_listbox.pack(pady=10)

    # Refresh listbox content
    def refresh_service_providers_list():
        service_providers_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for provider in profile_data.get('service_providers', []):
                provider_details = (
                    f"{provider['name']} | {provider['service_type']} | {provider['contact_number']} | "
                    f"{provider['email']} | {provider['address']} | {provider['notes']}"
                )
                service_providers_listbox.insert(tk.END, provider_details)

    # Save service provider details
    def save_service_provider():
        name = provider_name_entry.get()
        service_type = service_type_entry.get()
        contact_number = contact_number_entry.get()
        email = email_entry.get()
        address = address_entry.get()
        notes = notes_entry.get()

        if name and service_type and contact_number:
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'service_providers' not in profile_data:
                    profile_data['service_providers'] = []
                profile_data['service_providers'].append({
                    "name": name,
                    "service_type": service_type,
                    "contact_number": contact_number,
                    "email": email,
                    "address": address,
                    "notes": notes
                })
                # Clear the entry fields after saving
                provider_name_entry.delete(0, tk.END)
                service_type_entry.delete(0, tk.END)
                contact_number_entry.delete(0, tk.END)
                email_entry.delete(0, tk.END)
                address_entry.delete(0, tk.END)
                notes_entry.delete(0, tk.END)

                update_status_callback()  # Update the status label for this section
                refresh_service_providers_list()  # Refresh the list display
                save_profiles(profiles)  # Save profiles to file
        else:
            messagebox.showwarning("Input Error", "Please fill all required fields except Notes, Email, and Address (optional).")

    # Add button to save service provider
    tk.Button(scrollable_frame, text="Save Service Provider", command=save_service_provider).pack(pady=10)

    # Populate the listbox with existing service providers
    refresh_service_providers_list()


def open_power_of_attorney_window(profile_name, update_status_callback):
    poa_window = tk.Toplevel()
    poa_window.title(f"Manage Power of Attorney for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(poa_window)
    scrollbar = tk.Scrollbar(poa_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Fields for entering Power of Attorney details
    tk.Label(scrollable_frame, text="Attorney-In-Fact (Full Name):").pack(pady=5)
    name_entry = tk.Entry(scrollable_frame)
    name_entry.pack(pady=5)
    name_entry.focus_set()

    tk.Label(scrollable_frame, text="Type of Power of Attorney (e.g., General, Financial, Medical):").pack(pady=5)
    type_entry = tk.Entry(scrollable_frame)
    type_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Date of Execution (YYYY-MM-DD):").pack(pady=5)
    execution_date_entry = tk.Entry(scrollable_frame)
    execution_date_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Document Location (e.g., Physical Address, Digital File Path):").pack(pady=5)
    document_location_entry = tk.Entry(scrollable_frame)
    document_location_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Additional Notes:").pack(pady=5)
    notes_entry = tk.Entry(scrollable_frame)
    notes_entry.pack(pady=5)

    # Listbox for displaying Power of Attorney entries
    poa_listbox = tk.Listbox(scrollable_frame, height=10, width=70)
    poa_listbox.pack(pady=10)

    # Refresh listbox content
    def refresh_poa_list():
        poa_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for poa in profile_data.get('power_of_attorney', []):
                poa_details = (
                    f"{poa['name']} | {poa['type']} | {poa['execution_date']} | "
                    f"{poa['document_location']} | {poa['notes']}"
                )
                poa_listbox.insert(tk.END, poa_details)

    # Save Power of Attorney details
    def save_poa():
        name = name_entry.get()
        poa_type = type_entry.get()
        execution_date = execution_date_entry.get()
        document_location = document_location_entry.get()
        notes = notes_entry.get()

        if name and poa_type and execution_date and document_location:
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'power_of_attorney' not in profile_data:
                    profile_data['power_of_attorney'] = []
                profile_data['power_of_attorney'].append({
                    "name": name,
                    "type": poa_type,
                    "execution_date": execution_date,
                    "document_location": document_location,
                    "notes": notes
                })
                # Clear the entry fields after saving
                name_entry.delete(0, tk.END)
                type_entry.delete(0, tk.END)
                execution_date_entry.delete(0, tk.END)
                document_location_entry.delete(0, tk.END)
                notes_entry.delete(0, tk.END)

                update_status_callback()  # Update the status label for this section
                refresh_poa_list()  # Refresh the list display
                save_profiles(profiles)  # Save profiles to file
        else:
            messagebox.showwarning(
                "Input Error", "Please fill all required fields except Notes (optional)."
            )

    # Add button to save Power of Attorney
    tk.Button(scrollable_frame, text="Save Power of Attorney", command=save_poa).pack(pady=10)

    # Populate the listbox with existing Power of Attorney entries
    refresh_poa_list()

def open_organ_donation_window(profile_name, update_status_callback):
    organ_donation_window = tk.Toplevel()
    organ_donation_window.title(f"Manage Organ Donation for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(organ_donation_window)
    scrollbar = tk.Scrollbar(organ_donation_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Fields for entering organ donation details
    tk.Label(scrollable_frame, text="Are you registered as an organ donor? (Yes/No):").pack(pady=5)
    donor_status_entry = tk.Entry(scrollable_frame)
    donor_status_entry.pack(pady=5)
    donor_status_entry.focus_set()

    tk.Label(scrollable_frame, text="Registration Number or Details (if applicable):").pack(pady=5)
    registration_number_entry = tk.Entry(scrollable_frame)
    registration_number_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Specific Organs to Donate (if any):").pack(pady=5)
    specific_organs_entry = tk.Entry(scrollable_frame)
    specific_organs_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Additional Notes or Preferences:").pack(pady=5)
    notes_entry = tk.Entry(scrollable_frame)
    notes_entry.pack(pady=5)

    # Listbox for displaying organ donation details
    organ_donation_listbox = tk.Listbox(scrollable_frame, height=10, width=70)
    organ_donation_listbox.pack(pady=10)

    # Refresh listbox content
    def refresh_organ_donation_list():
        organ_donation_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for donation in profile_data.get('organ_donation', []):
                donation_details = (
                    f"Donor Status: {donation['donor_status']} | Registration: {donation['registration_number']} | "
                    f"Organs: {donation['specific_organs']} | Notes: {donation['notes']}"
                )
                organ_donation_listbox.insert(tk.END, donation_details)

    # Save organ donation details
    def save_organ_donation():
        donor_status = donor_status_entry.get()
        registration_number = registration_number_entry.get()
        specific_organs = specific_organs_entry.get()
        notes = notes_entry.get()

        if donor_status.lower() in ["yes", "no"]:
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'organ_donation' not in profile_data:
                    profile_data['organ_donation'] = []
                profile_data['organ_donation'].append({
                    "donor_status": donor_status.capitalize(),
                    "registration_number": registration_number,
                    "specific_organs": specific_organs,
                    "notes": notes
                })
                # Clear the entry fields after saving
                donor_status_entry.delete(0, tk.END)
                registration_number_entry.delete(0, tk.END)
                specific_organs_entry.delete(0, tk.END)
                notes_entry.delete(0, tk.END)

                update_status_callback()  # Update the status label for this section
                refresh_organ_donation_list()  # Refresh the list display
                save_profiles(profiles)  # Save profiles to file
        else:
            messagebox.showwarning(
                "Input Error", "Please enter 'Yes' or 'No' for donor status."
            )

    # Add button to save organ donation details
    tk.Button(scrollable_frame, text="Save Organ Donation", command=save_organ_donation).pack(pady=10)

    # Populate the listbox with existing organ donation entries
    refresh_organ_donation_list()

def open_burial_cremation_window(profile_name, update_status_callback):
    burial_cremation_window = tk.Toplevel()
    burial_cremation_window.title(f"Manage Burial or Cremation Preferences for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(burial_cremation_window)
    scrollbar = tk.Scrollbar(burial_cremation_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Fields for entering burial or cremation preferences
    tk.Label(scrollable_frame, text="Preferred Option (Burial/Cremation):").pack(pady=5)
    preference_entry = tk.Entry(scrollable_frame)
    preference_entry.pack(pady=5)
    preference_entry.focus_set()

    tk.Label(scrollable_frame, text="Location or Cemetery Name:").pack(pady=5)
    location_entry = tk.Entry(scrollable_frame)
    location_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Special Instructions or Wishes:").pack(pady=5)
    special_instructions_entry = tk.Entry(scrollable_frame)
    special_instructions_entry.pack(pady=5)

    # Listbox for displaying burial or cremation preferences
    burial_cremation_listbox = tk.Listbox(scrollable_frame, height=10, width=70)
    burial_cremation_listbox.pack(pady=10)

    # Refresh listbox content
    def refresh_burial_cremation_list():
        burial_cremation_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for option in profile_data.get('burial_cremation', []):
                option_details = (
                    f"Preference: {option['preference']} | Location: {option['location']} | "
                    f"Instructions: {option['instructions']}"
                )
                burial_cremation_listbox.insert(tk.END, option_details)

    # Save burial or cremation preferences
    def save_burial_cremation():
        preference = preference_entry.get().strip()
        location = location_entry.get().strip()
        instructions = special_instructions_entry.get().strip()

        if preference.lower() in ["burial", "cremation"]:
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'burial_cremation' not in profile_data:
                    profile_data['burial_cremation'] = []
                profile_data['burial_cremation'].append({
                    "preference": preference.capitalize(),
                    "location": location,
                    "instructions": instructions
                })
                # Clear the entry fields after saving
                preference_entry.delete(0, tk.END)
                location_entry.delete(0, tk.END)
                special_instructions_entry.delete(0, tk.END)

                update_status_callback()  # Update the status label for this section
                refresh_burial_cremation_list()  # Refresh the list display
                save_profiles(profiles)  # Save profiles to file
        else:
            messagebox.showwarning(
                "Input Error", "Please enter 'Burial' or 'Cremation' as the preferred option."
            )

    # Add button to save burial or cremation preferences
    tk.Button(scrollable_frame, text="Save Preferences", command=save_burial_cremation).pack(pady=10)

    # Populate the listbox with existing burial or cremation entries
    refresh_burial_cremation_list()

def open_funeral_services_window(profile_name, update_status_callback):
    funeral_services_window = tk.Toplevel()
    funeral_services_window.title(f"Manage Funeral Services for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(funeral_services_window)
    scrollbar = tk.Scrollbar(funeral_services_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Fields for entering funeral service details
    tk.Label(scrollable_frame, text="Funeral Home or Provider Name:").pack(pady=5)
    provider_name_entry = tk.Entry(scrollable_frame)
    provider_name_entry.pack(pady=5)
    provider_name_entry.focus_set()

    tk.Label(scrollable_frame, text="Address:").pack(pady=5)
    address_entry = tk.Entry(scrollable_frame)
    address_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Contact Number:").pack(pady=5)
    contact_number_entry = tk.Entry(scrollable_frame)
    contact_number_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Type of Service (e.g., Memorial, Viewing, Religious Ceremony):").pack(pady=5)
    service_type_entry = tk.Entry(scrollable_frame)
    service_type_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Special Instructions or Notes:").pack(pady=5)
    special_instructions_entry = tk.Entry(scrollable_frame)
    special_instructions_entry.pack(pady=5)

    # Listbox for displaying funeral service preferences
    funeral_services_listbox = tk.Listbox(scrollable_frame, height=10, width=70)
    funeral_services_listbox.pack(pady=10)

    # Refresh listbox content
    def refresh_funeral_services_list():
        funeral_services_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for service in profile_data.get('funeral_services', []):
                service_details = (
                    f"Provider: {service['provider']} | Address: {service['address']} | "
                    f"Contact: {service['contact']} | Type: {service['type']} | Notes: {service['notes']}"
                )
                funeral_services_listbox.insert(tk.END, service_details)

    # Save funeral service details
    def save_funeral_service():
        provider = provider_name_entry.get().strip()
        address = address_entry.get().strip()
        contact = contact_number_entry.get().strip()
        service_type = service_type_entry.get().strip()
        notes = special_instructions_entry.get().strip()

        if provider and service_type:
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'funeral_services' not in profile_data:
                    profile_data['funeral_services'] = []
                profile_data['funeral_services'].append({
                    "provider": provider,
                    "address": address,
                    "contact": contact,
                    "type": service_type,
                    "notes": notes
                })
                # Clear the entry fields after saving
                provider_name_entry.delete(0, tk.END)
                address_entry.delete(0, tk.END)
                contact_number_entry.delete(0, tk.END)
                service_type_entry.delete(0, tk.END)
                special_instructions_entry.delete(0, tk.END)

                update_status_callback()  # Update the status label for this section
                refresh_funeral_services_list()  # Refresh the list display
                save_profiles(profiles)  # Save profiles to file
        else:
            messagebox.showwarning(
                "Input Error", "Please fill in the Provider Name and Service Type fields."
            )

    # Add button to save funeral service details
    tk.Button(scrollable_frame, text="Save Funeral Service", command=save_funeral_service).pack(pady=10)

    # Populate the listbox with existing funeral service entries
    refresh_funeral_services_list()

def open_obituary_window(profile_name, update_status_callback):
    obituary_window = tk.Toplevel()
    obituary_window.title(f"Manage Obituary for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(obituary_window)
    scrollbar = tk.Scrollbar(obituary_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Fields for entering obituary details
    tk.Label(scrollable_frame, text="Obituary Title:").pack(pady=5)
    title_entry = tk.Entry(scrollable_frame, width=60)
    title_entry.pack(pady=5)
    title_entry.focus_set()

    tk.Label(scrollable_frame, text="Obituary Content:").pack(pady=5)
    content_text = tk.Text(scrollable_frame, height=15, width=70, wrap="word")
    content_text.pack(pady=5)

    # Obituary list display
    obituary_listbox = tk.Listbox(scrollable_frame, height=10, width=70)
    obituary_listbox.pack(pady=10)

    # Refresh listbox content
    def refresh_obituary_list():
        obituary_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for obituary in profile_data.get('obituaries', []):
                obituary_details = f"Title: {obituary['title']} | Content: {obituary['content'][:50]}..."
                obituary_listbox.insert(tk.END, obituary_details)

    # Save obituary details
    def save_obituary():
        title = title_entry.get().strip()
        content = content_text.get("1.0", tk.END).strip()

        if title and content:
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'obituaries' not in profile_data:
                    profile_data['obituaries'] = []
                profile_data['obituaries'].append({
                    "title": title,
                    "content": content
                })
                # Clear the entry fields after saving
                title_entry.delete(0, tk.END)
                content_text.delete("1.0", tk.END)

                update_status_callback()  # Update the status label for this section
                refresh_obituary_list()  # Refresh the list display
                save_profiles(profiles)  # Save profiles to file
        else:
            messagebox.showwarning("Input Error", "Please fill in both the title and the content.")

    # Add button to save obituary
    tk.Button(scrollable_frame, text="Save Obituary", command=save_obituary).pack(pady=10)

    # Populate the listbox with existing obituary entries
    refresh_obituary_list()


def open_will_and_trust_window(profile_name, update_status_callback):
    will_trust_window = tk.Toplevel()
    will_trust_window.title(f"Manage Will and Trust for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(will_trust_window)
    scrollbar = tk.Scrollbar(will_trust_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Fields for entering will and trust details
    tk.Label(scrollable_frame, text="Will Title:").pack(pady=5)
    will_title_entry = tk.Entry(scrollable_frame, width=60)
    will_title_entry.pack(pady=5)
    will_title_entry.focus_set()

    tk.Label(scrollable_frame, text="Executor Name:").pack(pady=5)
    executor_name_entry = tk.Entry(scrollable_frame, width=60)
    executor_name_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Beneficiaries (Comma-separated):").pack(pady=5)
    beneficiaries_entry = tk.Entry(scrollable_frame, width=60)
    beneficiaries_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Trust Details:").pack(pady=5)
    trust_details_text = tk.Text(scrollable_frame, height=10, width=70, wrap="word")
    trust_details_text.pack(pady=5)

    # Will and trust list display
    will_trust_listbox = tk.Listbox(scrollable_frame, height=10, width=70)
    will_trust_listbox.pack(pady=10)

    # Refresh listbox content
    def refresh_will_trust_list():
        will_trust_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for entry in profile_data.get('wills_and_trusts', []):
                entry_details = (
                    f"Will: {entry['will_title']} | Executor: {entry['executor_name']} | "
                    f"Beneficiaries: {entry['beneficiaries'][:50]} | Trust: {entry['trust_details'][:50]}..."
                )
                will_trust_listbox.insert(tk.END, entry_details)

    # Save will and trust details
    def save_will_trust():
        will_title = will_title_entry.get().strip()
        executor_name = executor_name_entry.get().strip()
        beneficiaries = beneficiaries_entry.get().strip()
        trust_details = trust_details_text.get("1.0", tk.END).strip()

        if will_title and executor_name and beneficiaries and trust_details:
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'wills_and_trusts' not in profile_data:
                    profile_data['wills_and_trusts'] = []
                profile_data['wills_and_trusts'].append({
                    "will_title": will_title,
                    "executor_name": executor_name,
                    "beneficiaries": beneficiaries,
                    "trust_details": trust_details
                })
                # Clear the entry fields after saving
                will_title_entry.delete(0, tk.END)
                executor_name_entry.delete(0, tk.END)
                beneficiaries_entry.delete(0, tk.END)
                trust_details_text.delete("1.0", tk.END)

                update_status_callback()  # Update the status label for this section
                refresh_will_trust_list()  # Refresh the list display
                save_profiles(profiles)  # Save profiles to file
        else:
            messagebox.showwarning("Input Error", "Please fill in all fields.")

    # Add button to save will and trust
    tk.Button(scrollable_frame, text="Save Will and Trust", command=save_will_trust).pack(pady=10)

    # Populate the listbox with existing will and trust entries
    refresh_will_trust_list()


def open_insurance_window(profile_name, update_status_callback):
    insurance_window = tk.Toplevel()
    insurance_window.title(f"Manage Insurance for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(insurance_window)
    scrollbar = tk.Scrollbar(insurance_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Fields for entering insurance details
    tk.Label(scrollable_frame, text="Insurance Type (e.g., Life, Health, Auto):").pack(pady=5)
    insurance_type_entry = tk.Entry(scrollable_frame, width=60)
    insurance_type_entry.pack(pady=5)
    insurance_type_entry.focus_set()

    tk.Label(scrollable_frame, text="Policy Number:").pack(pady=5)
    policy_number_entry = tk.Entry(scrollable_frame, width=60)
    policy_number_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Provider Name:").pack(pady=5)
    provider_name_entry = tk.Entry(scrollable_frame, width=60)
    provider_name_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Coverage Details:").pack(pady=5)
    coverage_details_text = tk.Text(scrollable_frame, height=6, width=70, wrap="word")
    coverage_details_text.pack(pady=5)

    tk.Label(scrollable_frame, text="Beneficiaries (Comma-separated):").pack(pady=5)
    beneficiaries_entry = tk.Entry(scrollable_frame, width=60)
    beneficiaries_entry.pack(pady=5)

    # Insurance list display
    insurance_listbox = tk.Listbox(scrollable_frame, height=10, width=70)
    insurance_listbox.pack(pady=10)

    # Refresh listbox content
    def refresh_insurance_list():
        insurance_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for insurance in profile_data.get('insurance', []):
                insurance_details = (
                    f"Type: {insurance['type']} | Policy #: {insurance['policy_number']} | "
                    f"Provider: {insurance['provider_name']} | Beneficiaries: {insurance['beneficiaries'][:50]}"
                )
                insurance_listbox.insert(tk.END, insurance_details)

    # Save insurance details
    def save_insurance():
        insurance_type = insurance_type_entry.get().strip()
        policy_number = policy_number_entry.get().strip()
        provider_name = provider_name_entry.get().strip()
        coverage_details = coverage_details_text.get("1.0", tk.END).strip()
        beneficiaries = beneficiaries_entry.get().strip()

        if insurance_type and policy_number and provider_name and coverage_details:
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'insurance' not in profile_data:
                    profile_data['insurance'] = []
                profile_data['insurance'].append({
                    "type": insurance_type,
                    "policy_number": policy_number,
                    "provider_name": provider_name,
                    "coverage_details": coverage_details,
                    "beneficiaries": beneficiaries
                })
                # Clear the entry fields after saving
                insurance_type_entry.delete(0, tk.END)
                policy_number_entry.delete(0, tk.END)
                provider_name_entry.delete(0, tk.END)
                coverage_details_text.delete("1.0", tk.END)
                beneficiaries_entry.delete(0, tk.END)

                update_status_callback()  # Update the status label for this section
                refresh_insurance_list()  # Refresh the list display
                save_profiles(profiles)  # Save profiles to file
        else:
            messagebox.showwarning("Input Error", "Please fill in all required fields.")

    # Add button to save insurance
    tk.Button(scrollable_frame, text="Save Insurance", command=save_insurance).pack(pady=10)

    # Populate the listbox with existing insurance entries
    refresh_insurance_list()


def open_banking_window(profile_name, update_status_callback):
    banking_window = tk.Toplevel()
    banking_window.title(f"Manage Banking Information for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(banking_window)
    scrollbar = tk.Scrollbar(banking_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Fields for entering banking details
    tk.Label(scrollable_frame, text="Bank Name:").pack(pady=5)
    bank_name_entry = tk.Entry(scrollable_frame, width=60)
    bank_name_entry.pack(pady=5)
    bank_name_entry.focus_set()

    tk.Label(scrollable_frame, text="Account Type (e.g., Checking, Savings):").pack(pady=5)
    account_type_entry = tk.Entry(scrollable_frame, width=60)
    account_type_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Account Number:").pack(pady=5)
    account_number_entry = tk.Entry(scrollable_frame, width=60)
    account_number_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Branch Location:").pack(pady=5)
    branch_location_entry = tk.Entry(scrollable_frame, width=60)
    branch_location_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Additional Notes:").pack(pady=5)
    notes_text = tk.Text(scrollable_frame, height=6, width=70, wrap="word")
    notes_text.pack(pady=5)

    # Banking list display
    banking_listbox = tk.Listbox(scrollable_frame, height=10, width=70)
    banking_listbox.pack(pady=10)

    # Refresh listbox content
    def refresh_banking_list():
        banking_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for bank in profile_data.get('banking', []):
                bank_details = (
                    f"Bank: {bank['bank_name']} | Account Type: {bank['account_type']} | "
                    f"Account #: {bank['account_number']} | Branch: {bank['branch_location']}"
                )
                banking_listbox.insert(tk.END, bank_details)

    # Save banking details
    def save_banking():
        bank_name = bank_name_entry.get().strip()
        account_type = account_type_entry.get().strip()
        account_number = account_number_entry.get().strip()
        branch_location = branch_location_entry.get().strip()
        notes = notes_text.get("1.0", tk.END).strip()

        if bank_name and account_type and account_number and branch_location:
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'banking' not in profile_data:
                    profile_data['banking'] = []
                profile_data['banking'].append({
                    "bank_name": bank_name,
                    "account_type": account_type,
                    "account_number": account_number,
                    "branch_location": branch_location,
                    "notes": notes
                })
                # Clear the entry fields after saving
                bank_name_entry.delete(0, tk.END)
                account_type_entry.delete(0, tk.END)
                account_number_entry.delete(0, tk.END)
                branch_location_entry.delete(0, tk.END)
                notes_text.delete("1.0", tk.END)

                update_status_callback()  # Update the status label for this section
                refresh_banking_list()  # Refresh the list display
                save_profiles(profiles)  # Save profiles to file
        else:
            messagebox.showwarning("Input Error", "Please fill in all required fields.")

    # Add button to save banking details
    tk.Button(scrollable_frame, text="Save Banking Details", command=save_banking).pack(pady=10)

    # Populate the listbox with existing banking entries
    refresh_banking_list()



def open_retirement_window(profile_name, update_status_callback):
    retirement_window = tk.Toplevel()
    retirement_window.title(f"Manage Retirement Information for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(retirement_window)
    scrollbar = tk.Scrollbar(retirement_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Fields for entering retirement details
    tk.Label(scrollable_frame, text="Retirement Plan Name:").pack(pady=5)
    plan_name_entry = tk.Entry(scrollable_frame, width=60)
    plan_name_entry.pack(pady=5)
    plan_name_entry.focus_set()

    tk.Label(scrollable_frame, text="Account Type (e.g., 401(k), IRA):").pack(pady=5)
    account_type_entry = tk.Entry(scrollable_frame, width=60)
    account_type_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Account Number:").pack(pady=5)
    account_number_entry = tk.Entry(scrollable_frame, width=60)
    account_number_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Provider (e.g., Vanguard, Fidelity):").pack(pady=5)
    provider_entry = tk.Entry(scrollable_frame, width=60)
    provider_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Beneficiaries:").pack(pady=5)
    beneficiaries_entry = tk.Entry(scrollable_frame, width=60)
    beneficiaries_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Additional Notes:").pack(pady=5)
    notes_text = tk.Text(scrollable_frame, height=6, width=70, wrap="word")
    notes_text.pack(pady=5)

    # Retirement list display
    retirement_listbox = tk.Listbox(scrollable_frame, height=10, width=70)
    retirement_listbox.pack(pady=10)

    # Refresh listbox content
    def refresh_retirement_list():
        retirement_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for plan in profile_data.get('retirement', []):
                plan_details = (
                    f"Plan: {plan['plan_name']} | Type: {plan['account_type']} | "
                    f"Provider: {plan['provider']} | Beneficiaries: {plan['beneficiaries']}"
                )
                retirement_listbox.insert(tk.END, plan_details)

    # Save retirement details
    def save_retirement():
        plan_name = plan_name_entry.get().strip()
        account_type = account_type_entry.get().strip()
        account_number = account_number_entry.get().strip()
        provider = provider_entry.get().strip()
        beneficiaries = beneficiaries_entry.get().strip()
        notes = notes_text.get("1.0", tk.END).strip()

        if plan_name and account_type and account_number and provider:
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'retirement' not in profile_data:
                    profile_data['retirement'] = []
                profile_data['retirement'].append({
                    "plan_name": plan_name,
                    "account_type": account_type,
                    "account_number": account_number,
                    "provider": provider,
                    "beneficiaries": beneficiaries,
                    "notes": notes
                })
                # Clear the entry fields after saving
                plan_name_entry.delete(0, tk.END)
                account_type_entry.delete(0, tk.END)
                account_number_entry.delete(0, tk.END)
                provider_entry.delete(0, tk.END)
                beneficiaries_entry.delete(0, tk.END)
                notes_text.delete("1.0", tk.END)

                update_status_callback()  # Update the status label for this section
                refresh_retirement_list()  # Refresh the list display
                save_profiles(profiles)  # Save profiles to file
        else:
            messagebox.showwarning("Input Error", "Please fill in all required fields.")

    # Add button to save retirement details
    tk.Button(scrollable_frame, text="Save Retirement Details", command=save_retirement).pack(pady=10)

    # Populate the listbox with existing retirement entries
    refresh_retirement_list()


def open_government_benefits_window(profile_name, update_status_callback):
    benefits_window = tk.Toplevel()
    benefits_window.title(f"Manage Government Benefits for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(benefits_window)
    scrollbar = tk.Scrollbar(benefits_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Fields for entering government benefits details
    tk.Label(scrollable_frame, text="Benefit Type (e.g., Social Security, Medicare):").pack(pady=5)
    benefit_type_entry = tk.Entry(scrollable_frame, width=60)
    benefit_type_entry.pack(pady=5)
    benefit_type_entry.focus_set()

    tk.Label(scrollable_frame, text="Account Number:").pack(pady=5)
    account_number_entry = tk.Entry(scrollable_frame, width=60)
    account_number_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Agency/Provider (e.g., SSA, VA):").pack(pady=5)
    agency_entry = tk.Entry(scrollable_frame, width=60)
    agency_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Start Date (YYYY-MM-DD):").pack(pady=5)
    start_date_entry = tk.Entry(scrollable_frame, width=60)
    start_date_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Monthly Benefit Amount:").pack(pady=5)
    monthly_amount_entry = tk.Entry(scrollable_frame, width=60)
    monthly_amount_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Additional Notes:").pack(pady=5)
    notes_text = tk.Text(scrollable_frame, height=6, width=70, wrap="word")
    notes_text.pack(pady=5)

    # Government benefits list display
    benefits_listbox = tk.Listbox(scrollable_frame, height=10, width=70)
    benefits_listbox.pack(pady=10)

    # Refresh listbox content
    def refresh_benefits_list():
        benefits_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for benefit in profile_data.get('government_benefits', []):
                benefit_details = (
                    f"Type: {benefit['benefit_type']} | Agency: {benefit['agency']} | "
                    f"Start Date: {benefit['start_date']} | Monthly Amount: ${benefit['monthly_amount']}"
                )
                benefits_listbox.insert(tk.END, benefit_details)

    # Save government benefits details
    def save_benefit():
        benefit_type = benefit_type_entry.get().strip()
        account_number = account_number_entry.get().strip()
        agency = agency_entry.get().strip()
        start_date = start_date_entry.get().strip()
        monthly_amount = monthly_amount_entry.get().strip()
        notes = notes_text.get("1.0", tk.END).strip()

        if benefit_type and account_number and agency and start_date and monthly_amount:
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'government_benefits' not in profile_data:
                    profile_data['government_benefits'] = []
                profile_data['government_benefits'].append({
                    "benefit_type": benefit_type,
                    "account_number": account_number,
                    "agency": agency,
                    "start_date": start_date,
                    "monthly_amount": monthly_amount,
                    "notes": notes
                })
                # Clear the entry fields after saving
                benefit_type_entry.delete(0, tk.END)
                account_number_entry.delete(0, tk.END)
                agency_entry.delete(0, tk.END)
                start_date_entry.delete(0, tk.END)
                monthly_amount_entry.delete(0, tk.END)
                notes_text.delete("1.0", tk.END)

                update_status_callback()  # Update the status label for this section
                refresh_benefits_list()  # Refresh the list display
                save_profiles(profiles)  # Save profiles to file
        else:
            messagebox.showwarning("Input Error", "Please fill in all required fields.")

    # Add button to save government benefits details
    tk.Button(scrollable_frame, text="Save Government Benefit", command=save_benefit).pack(pady=10)

    # Populate the listbox with existing government benefits entries
    refresh_benefits_list()


def open_credit_debt_window(profile_name, update_status_callback):
    credit_debt_window = tk.Toplevel()
    credit_debt_window.title(f"Manage Credit and Debt for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(credit_debt_window)
    scrollbar = tk.Scrollbar(credit_debt_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Fields for entering credit and debt details
    tk.Label(scrollable_frame, text="Type (e.g., Credit Card, Loan):").pack(pady=5)
    debt_type_entry = tk.Entry(scrollable_frame, width=60)
    debt_type_entry.pack(pady=5)
    debt_type_entry.focus_set()

    tk.Label(scrollable_frame, text="Account Number:").pack(pady=5)
    account_number_entry = tk.Entry(scrollable_frame, width=60)
    account_number_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Lender Name (e.g., Bank, Credit Union):").pack(pady=5)
    lender_entry = tk.Entry(scrollable_frame, width=60)
    lender_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Outstanding Balance ($):").pack(pady=5)
    balance_entry = tk.Entry(scrollable_frame, width=60)
    balance_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Interest Rate (%):").pack(pady=5)
    interest_rate_entry = tk.Entry(scrollable_frame, width=60)
    interest_rate_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Monthly Payment ($):").pack(pady=5)
    monthly_payment_entry = tk.Entry(scrollable_frame, width=60)
    monthly_payment_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Due Date (YYYY-MM-DD):").pack(pady=5)
    due_date_entry = tk.Entry(scrollable_frame, width=60)
    due_date_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Additional Notes:").pack(pady=5)
    notes_text = tk.Text(scrollable_frame, height=6, width=70, wrap="word")
    notes_text.pack(pady=5)

    # Credit and debt list display
    credit_debt_listbox = tk.Listbox(scrollable_frame, height=10, width=70)
    credit_debt_listbox.pack(pady=10)

    # Refresh listbox content
    def refresh_credit_debt_list():
        credit_debt_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for debt in profile_data.get('credit_debt', []):
                debt_details = (
                    f"Type: {debt['type']} | Lender: {debt['lender']} | "
                    f"Balance: ${debt['balance']} | Due Date: {debt['due_date']}"
                )
                credit_debt_listbox.insert(tk.END, debt_details)

    # Save credit and debt details
    def save_credit_debt():
        debt_type = debt_type_entry.get().strip()
        account_number = account_number_entry.get().strip()
        lender = lender_entry.get().strip()
        balance = balance_entry.get().strip()
        interest_rate = interest_rate_entry.get().strip()
        monthly_payment = monthly_payment_entry.get().strip()
        due_date = due_date_entry.get().strip()
        notes = notes_text.get("1.0", tk.END).strip()

        if debt_type and account_number and lender and balance and due_date:
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'credit_debt' not in profile_data:
                    profile_data['credit_debt'] = []
                profile_data['credit_debt'].append({
                    "type": debt_type,
                    "account_number": account_number,
                    "lender": lender,
                    "balance": balance,
                    "interest_rate": interest_rate,
                    "monthly_payment": monthly_payment,
                    "due_date": due_date,
                    "notes": notes
                })
                # Clear the entry fields after saving
                debt_type_entry.delete(0, tk.END)
                account_number_entry.delete(0, tk.END)
                lender_entry.delete(0, tk.END)
                balance_entry.delete(0, tk.END)
                interest_rate_entry.delete(0, tk.END)
                monthly_payment_entry.delete(0, tk.END)
                due_date_entry.delete(0, tk.END)
                notes_text.delete("1.0", tk.END)

                update_status_callback()  # Update the status label for this section
                refresh_credit_debt_list()  # Refresh the list display
                save_profiles(profiles)  # Save profiles to file
        else:
            messagebox.showwarning("Input Error", "Please fill in all required fields.")

    # Add button to save credit and debt details
    tk.Button(scrollable_frame, text="Save Credit/Debt", command=save_credit_debt).pack(pady=10)

    # Populate the listbox with existing credit and debt entries
    refresh_credit_debt_list()

def open_secured_places_window(profile_name, update_status_callback):
    secured_places_window = tk.Toplevel()
    secured_places_window.title(f"Manage Secured Places for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(secured_places_window)
    scrollbar = tk.Scrollbar(secured_places_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Fields for entering secured place details
    tk.Label(scrollable_frame, text="Name or Type of Secured Place (e.g., Safe, Storage Unit):").pack(pady=5)
    place_type_entry = tk.Entry(scrollable_frame, width=60)
    place_type_entry.pack(pady=5)
    place_type_entry.focus_set()

    tk.Label(scrollable_frame, text="Location or Address:").pack(pady=5)
    location_entry = tk.Entry(scrollable_frame, width=60)
    location_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Access Details (e.g., Key, Code, Combination):").pack(pady=5)
    access_details_entry = tk.Entry(scrollable_frame, width=60)
    access_details_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Contents or Items Stored:").pack(pady=5)
    contents_text = tk.Text(scrollable_frame, height=6, width=70, wrap="word")
    contents_text.pack(pady=5)

    tk.Label(scrollable_frame, text="Additional Notes:").pack(pady=5)
    notes_text = tk.Text(scrollable_frame, height=6, width=70, wrap="word")
    notes_text.pack(pady=5)

    # Secured places list display
    secured_places_listbox = tk.Listbox(scrollable_frame, height=10, width=70)
    secured_places_listbox.pack(pady=10)

    # Refresh listbox content
    def refresh_secured_places_list():
        secured_places_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for place in profile_data.get('secured_places', []):
                place_details = (
                    f"Type: {place['type']} | Location: {place['location']} | Access: {place['access_details']}"
                )
                secured_places_listbox.insert(tk.END, place_details)

    # Save secured place details
    def save_secured_place():
        place_type = place_type_entry.get().strip()
        location = location_entry.get().strip()
        access_details = access_details_entry.get().strip()
        contents = contents_text.get("1.0", tk.END).strip()
        notes = notes_text.get("1.0", tk.END).strip()

        if place_type and location and access_details:
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'secured_places' not in profile_data:
                    profile_data['secured_places'] = []
                profile_data['secured_places'].append({
                    "type": place_type,
                    "location": location,
                    "access_details": access_details,
                    "contents": contents,
                    "notes": notes
                })
                # Clear the entry fields after saving
                place_type_entry.delete(0, tk.END)
                location_entry.delete(0, tk.END)
                access_details_entry.delete(0, tk.END)
                contents_text.delete("1.0", tk.END)
                notes_text.delete("1.0", tk.END)

                update_status_callback()  # Update the status label for this section
                refresh_secured_places_list()  # Refresh the list display
                save_profiles(profiles)  # Save profiles to file
        else:
            messagebox.showwarning("Input Error", "Please fill in all required fields.")

    # Add button to save secured place details
    tk.Button(scrollable_frame, text="Save Secured Place", command=save_secured_place).pack(pady=10)

    # Populate the listbox with existing secured place entries
    refresh_secured_places_list()


def open_taxes_window(profile_name, update_status_callback):
    taxes_window = tk.Toplevel()
    taxes_window.title(f"Manage Taxes for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(taxes_window)
    scrollbar = tk.Scrollbar(taxes_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Fields for entering tax information
    tk.Label(scrollable_frame, text="Taxpayer Name or Entity:").pack(pady=5)
    taxpayer_entry = tk.Entry(scrollable_frame, width=60)
    taxpayer_entry.pack(pady=5)
    taxpayer_entry.focus_set()

    tk.Label(scrollable_frame, text="Tax ID (e.g., SSN, EIN, or ITIN):").pack(pady=5)
    tax_id_entry = tk.Entry(scrollable_frame, width=60)
    tax_id_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Tax Filing Year:").pack(pady=5)
    filing_year_entry = tk.Entry(scrollable_frame, width=60)
    filing_year_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Documents or References:").pack(pady=5)
    documents_text = tk.Text(scrollable_frame, height=6, width=70, wrap="word")
    documents_text.pack(pady=5)

    tk.Label(scrollable_frame, text="Additional Notes:").pack(pady=5)
    notes_text = tk.Text(scrollable_frame, height=6, width=70, wrap="word")
    notes_text.pack(pady=5)

    # Tax records list display
    taxes_listbox = tk.Listbox(scrollable_frame, height=10, width=70)
    taxes_listbox.pack(pady=10)

    # Refresh listbox content
    def refresh_taxes_list():
        taxes_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for tax_record in profile_data.get('taxes', []):
                tax_details = (
                    f"Name: {tax_record['taxpayer']} | Tax ID: {tax_record['tax_id']} | Year: {tax_record['filing_year']}"
                )
                taxes_listbox.insert(tk.END, tax_details)

    # Save tax record
    def save_tax_record():
        taxpayer = taxpayer_entry.get().strip()
        tax_id = tax_id_entry.get().strip()
        filing_year = filing_year_entry.get().strip()
        documents = documents_text.get("1.0", tk.END).strip()
        notes = notes_text.get("1.0", tk.END).strip()

        if taxpayer and tax_id and filing_year:
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'taxes' not in profile_data:
                    profile_data['taxes'] = []
                profile_data['taxes'].append({
                    "taxpayer": taxpayer,
                    "tax_id": tax_id,
                    "filing_year": filing_year,
                    "documents": documents,
                    "notes": notes
                })
                # Clear the entry fields after saving
                taxpayer_entry.delete(0, tk.END)
                tax_id_entry.delete(0, tk.END)
                filing_year_entry.delete(0, tk.END)
                documents_text.delete("1.0", tk.END)
                notes_text.delete("1.0", tk.END)

                update_status_callback()  # Update the status label for this section
                refresh_taxes_list()  # Refresh the list display
                save_profiles(profiles)  # Save profiles to file
        else:
            messagebox.showwarning("Input Error", "Please fill in all required fields.")

    # Add button to save tax record
    tk.Button(scrollable_frame, text="Save Tax Record", command=save_tax_record).pack(pady=10)

    # Populate the listbox with existing tax records
    refresh_taxes_list()

def open_real_estate_window(profile_name, update_status_callback):
    real_estate_window = tk.Toplevel()
    real_estate_window.title(f"Manage Real Estate for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(real_estate_window)
    scrollbar = tk.Scrollbar(real_estate_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Fields for entering real estate information
    tk.Label(scrollable_frame, text="Property Address:").pack(pady=5)
    address_entry = tk.Entry(scrollable_frame, width=60)
    address_entry.pack(pady=5)
    address_entry.focus_set()

    tk.Label(scrollable_frame, text="Property Type (e.g., Residential, Commercial):").pack(pady=5)
    property_type_entry = tk.Entry(scrollable_frame, width=60)
    property_type_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Ownership Details:").pack(pady=5)
    ownership_entry = tk.Entry(scrollable_frame, width=60)
    ownership_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Mortgage Details:").pack(pady=5)
    mortgage_text = tk.Text(scrollable_frame, height=6, width=70, wrap="word")
    mortgage_text.pack(pady=5)

    tk.Label(scrollable_frame, text="Additional Notes:").pack(pady=5)
    notes_text = tk.Text(scrollable_frame, height=6, width=70, wrap="word")
    notes_text.pack(pady=5)

    # Listbox to display saved properties
    properties_listbox = tk.Listbox(scrollable_frame, height=10, width=70)
    properties_listbox.pack(pady=10)

    # Refresh the listbox content
    def refresh_properties_list():
        properties_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for property_record in profile_data.get('real_estate', []):
                property_details = (
                    f"Address: {property_record['address']} | Type: {property_record['property_type']}"
                )
                properties_listbox.insert(tk.END, property_details)

    # Save real estate record
    def save_property_record():
        address = address_entry.get().strip()
        property_type = property_type_entry.get().strip()
        ownership = ownership_entry.get().strip()
        mortgage = mortgage_text.get("1.0", tk.END).strip()
        notes = notes_text.get("1.0", tk.END).strip()

        if address and property_type and ownership:
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'real_estate' not in profile_data:
                    profile_data['real_estate'] = []
                profile_data['real_estate'].append({
                    "address": address,
                    "property_type": property_type,
                    "ownership": ownership,
                    "mortgage": mortgage,
                    "notes": notes
                })
                # Clear the entry fields after saving
                address_entry.delete(0, tk.END)
                property_type_entry.delete(0, tk.END)
                ownership_entry.delete(0, tk.END)
                mortgage_text.delete("1.0", tk.END)
                notes_text.delete("1.0", tk.END)

                update_status_callback()  # Update the status label for this section
                refresh_properties_list()  # Refresh the list display
                save_profiles(profiles)  # Save profiles to file
        else:
            messagebox.showwarning("Input Error", "Please fill in all required fields.")

    # Add button to save property record
    tk.Button(scrollable_frame, text="Save Property Record", command=save_property_record).pack(pady=10)

    # Populate the listbox with existing property records
    refresh_properties_list()

def open_personal_property_window(profile_name, update_status_callback):
    personal_property_window = tk.Toplevel()
    personal_property_window.title(f"Manage Personal Property for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(personal_property_window)
    scrollbar = tk.Scrollbar(personal_property_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Fields for entering personal property information
    tk.Label(scrollable_frame, text="Item Name:").pack(pady=5)
    item_name_entry = tk.Entry(scrollable_frame, width=60)
    item_name_entry.pack(pady=5)
    item_name_entry.focus_set()

    tk.Label(scrollable_frame, text="Item Description:").pack(pady=5)
    item_description_text = tk.Text(scrollable_frame, height=4, width=70, wrap="word")
    item_description_text.pack(pady=5)

    tk.Label(scrollable_frame, text="Estimated Value:").pack(pady=5)
    item_value_entry = tk.Entry(scrollable_frame, width=60)
    item_value_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Location:").pack(pady=5)
    item_location_entry = tk.Entry(scrollable_frame, width=60)
    item_location_entry.pack(pady=5)

    # Listbox to display saved items
    items_listbox = tk.Listbox(scrollable_frame, height=10, width=70)
    items_listbox.pack(pady=10)

    # Refresh the listbox content
    def refresh_items_list():
        items_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for item in profile_data.get('personal_property', []):
                item_details = f"Name: {item['name']} | Value: ${item['value']}"
                items_listbox.insert(tk.END, item_details)

    # Save personal property record
    def save_item_record():
        name = item_name_entry.get().strip()
        description = item_description_text.get("1.0", tk.END).strip()
        value = item_value_entry.get().strip()
        location = item_location_entry.get().strip()

        if name and value and location:
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'personal_property' not in profile_data:
                    profile_data['personal_property'] = []
                profile_data['personal_property'].append({
                    "name": name,
                    "description": description,
                    "value": value,
                    "location": location
                })
                # Clear the entry fields after saving
                item_name_entry.delete(0, tk.END)
                item_description_text.delete("1.0", tk.END)
                item_value_entry.delete(0, tk.END)
                item_location_entry.delete(0, tk.END)

                update_status_callback()  # Update the status label for this section
                refresh_items_list()  # Refresh the list display
                save_profiles(profiles)  # Save profiles to file
        else:
            messagebox.showwarning("Input Error", "Please fill in all required fields (Name, Value, Location).")

    # Add button to save item record
    tk.Button(scrollable_frame, text="Save Item Record", command=save_item_record).pack(pady=10)

    # Populate the listbox with existing personal property records
    refresh_items_list()

def open_other_information_window(profile_name, update_status_callback):
    other_information_window = tk.Toplevel()
    other_information_window.title(f"Manage Other Information for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(other_information_window)
    scrollbar = tk.Scrollbar(other_information_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Fields for entering other information
    tk.Label(scrollable_frame, text="Title (e.g., Special Wishes, Notes, etc.):").pack(pady=5)
    title_entry = tk.Entry(scrollable_frame, width=60)
    title_entry.pack(pady=5)
    title_entry.focus_set()

    tk.Label(scrollable_frame, text="Description/Details:").pack(pady=5)
    details_text = tk.Text(scrollable_frame, height=6, width=70, wrap="word")
    details_text.pack(pady=5)

    # Listbox to display saved other information entries
    other_info_listbox = tk.Listbox(scrollable_frame, height=10, width=70)
    other_info_listbox.pack(pady=10)

    # Refresh the listbox content
    def refresh_other_info_list():
        other_info_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for info in profile_data.get('other_information', []):
                info_details = f"Title: {info['title']} | {info['description'][:50]}..."  # Show truncated description
                other_info_listbox.insert(tk.END, info_details)

    # Save other information record
    def save_other_info():
        title = title_entry.get().strip()
        description = details_text.get("1.0", tk.END).strip()

        if title and description:
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'other_information' not in profile_data:
                    profile_data['other_information'] = []
                profile_data['other_information'].append({
                    "title": title,
                    "description": description
                })
                # Clear the entry fields after saving
                title_entry.delete(0, tk.END)
                details_text.delete("1.0", tk.END)

                update_status_callback()  # Update the status label for this section
                refresh_other_info_list()  # Refresh the list display
                save_profiles(profiles)  # Save profiles to file
        else:
            messagebox.showwarning("Input Error", "Please fill in both the Title and Description.")

    # Add button to save other information
    tk.Button(scrollable_frame, text="Save Information", command=save_other_info).pack(pady=10)

    # Populate the listbox with existing other information records
    refresh_other_info_list()




from tkinter import filedialog

def generate_profile_pdf(profile_name):
    """Generate a PDF for the highlighted profile."""
    profile_data = next((p for p in profiles if p['name'] == profile_name), None)
    if not profile_data:
        messagebox.showwarning("Error", f"No data found for profile '{profile_name}'")
        return

    # Prompt the user to select a folder
    folder_path = filedialog.askdirectory(title="Select Folder to Save PDF")
    if not folder_path:
        return  # User canceled folder selection

    # Construct the full file path
    pdf_filename = f"{profile_name}_profile.pdf"
    file_path = f"{folder_path}/{pdf_filename}"

    # Initialize PDF
    c = canvas.Canvas(file_path, pagesize=letter)
    width, height = letter

    # Title
    c.setFont("Helvetica", 16)
    c.drawString(100, height - 40, f"Profile Summary for {profile_name}")

    # Starting Y position for content
    y_position = height - 80

    # Function to recursively process and write nested data
    def write_data(data, indent=0):
        nonlocal y_position
        if isinstance(data, dict):
            for key, value in data.items():
                c.setFont("Helvetica", 10)
                c.drawString(120 + indent, y_position, f"{key.capitalize()}:")
                y_position -= 15
                write_data(value, indent + 20)
        elif isinstance(data, list):
            for item in data:
                write_data(item, indent)
        else:
            c.setFont("Helvetica", 10)
            c.drawString(120 + indent, y_position, f"- {data}")
            y_position -= 15

    # Add profile sections
    for section_title, section_content in profile_data.items():
        if section_title != 'name':  # Skip the profile name in sections
            c.setFont("Helvetica-Bold", 12)
            c.drawString(100, y_position, f"{section_title.capitalize()}:")
            y_position -= 20
            if section_content:
                write_data(section_content)
            else:
                c.setFont("Helvetica", 10)
                c.drawString(120, y_position, "No data available.")
                y_position -= 15

            # Check for page overflow
            if y_position < 40:
                c.showPage()
                y_position = height - 40

    # Save PDF
    c.save()
    messagebox.showinfo("PDF Generated", f"PDF for '{profile_name}' has been saved to '{file_path}'.")


# Function to handle double-click on a profile in the listbox
import tkinter as tk
from tkinter import messagebox

# Sample profiles list


def on_profile_double_click(event):
    selected_index = profiles_listbox.curselection()
    if selected_index:
        selected_profile_name = profiles_listbox.get(selected_index[0])
        open_profile_window(selected_profile_name)

def on_generate_pdf_click():
    """Handle the 'Generate PDF' button click."""
    selected_index = profiles_listbox.curselection()
    if selected_index:
        selected_profile_name = profiles_listbox.get(selected_index[0])
        generate_profile_pdf(selected_profile_name)
    else:
        messagebox.showwarning("Selection Error", "Please select a profile to generate a PDF.")

# Function to open a popup window to add a new profile
def open_add_profile_window():
    popup = tk.Toplevel(root)
    popup.title("Add New Profile")
    popup.geometry("300x150")

    tk.Label(popup, text="Enter Profile Name:").pack(pady=5)
    
    entry = tk.Entry(popup)
    entry.pack(pady=5)
    entry.focus()  # Auto-focus the entry field

    def add_new_profile():
        new_profile_name = entry.get().strip()
        if new_profile_name:
            if any(p['name'] == new_profile_name for p in profiles):
                messagebox.showwarning("Duplicate Profile", "A profile with this name already exists.")
            else:
                profiles.append({'name': new_profile_name})
                save_profiles(profiles)
                profiles_listbox.insert(tk.END, new_profile_name)
                messagebox.showinfo("Profile Added", f"Profile '{new_profile_name}' has been added.")
                popup.destroy()  # Close the popup window
        else:
            messagebox.showwarning("Input Error", "Please enter a profile name.")

    tk.Button(popup, text="Add Profile", command=add_new_profile).pack(pady=5)

# Main window setup
root = tk.Tk()
root.title("Profiles Management")

tk.Label(root, text="Profiles", font=("Arial", 30)).pack(pady=10)

profiles_listbox = tk.Listbox(root, height=10, width=50)
profiles_listbox.pack(pady=10)
for profile in profiles:
    profiles_listbox.insert(tk.END, profile['name'])

profiles_listbox.bind("<Double-Button-1>", on_profile_double_click)

# Button to open the add profile popup
tk.Button(root, text="Add New Profile", command=open_add_profile_window).pack(pady=5)

# Button to generate a PDF for the highlighted profile
tk.Button(root, text="Generate PDF", command=on_generate_pdf_click).pack(pady=5)

# Start the main loop
root.mainloop()
